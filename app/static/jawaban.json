["Rinaldi Munir", "Kevin Andrian Liwinata", "144 SKS", "Sistem Komunikasi Satelit Domestik", "17 April 2019", "4 Kali", "5 tahun sekali", "<tuliskan nama anggota kelompok>", "<tuliskan stack yang dipakai>", "DKI Jakarta", "Jayakarta", "Knuth-Morris-Prat", "Magnus Carlsen", "Blackhole M87", "velove vexia", "Tujuh orang", "1945", "3 setengah tahun", "Jl", "Kantin Borju", "Mulai tahun 2013, ITB menerapkan ketentuan Uang Kuliah Tunggal (UKT) bagi mahasiswa. Besaran Uang Kuliah Tunggal (UKT) tahun 2018 di ITB (untuk fakultas/sekolah non SBM) adalah sebesar Rp. 12.500.000,- (Dua Belas Juta Lima Ratus Ribu Rupiah) per semester. Sedangkan biaya pendidikan untuk Sekolah Bisnis dan Manajemen adalah sebesar Rp. 20.000.000,- (Dua puluh Juta Rupiah) per semester. Bagi para mahasiswa yang memerlukan bantuan biaya pendidikan dan memenuhi kriteria yang ditentukan, disediakan bantuan biaya pendidikan yang disesuaikan dengan kemampuan ekonomi orang tua. Informasi selengkapnya dapat diperoleh di alamat http://usm.itb.ac.id/.", "Mulai tahun 2013, ITB menerapkan ketentuan Uang Kuliah Tunggal (UKT). ITB tidak memberlakukan kebijakan uang pangkal dalam bentuk apa pun. Informasi selengkapnya dapat diperoleh di alamat http://usm.itb.ac.id/.", "Subsidi UKT diberikan ITB bagi calon mahasiswa yang tidak mampu secara ekonomi, dengan besaran subsidi yang akan ditentukan oleh ITB berdasarkan data ekonomi mahasiswa yang bersangkutan. Mekanisme penentuan subsidi UKT tersebut akan disampaikan kepada calon mahasiswa setelah yang bersangkutan dinyatakan lulus dari salah satu sistem seleksi mahasiswa baru (SNMPTN atau SBMPTN) di ITB. Sebagai informasi, jumlah mahasiswa ITB yang membayar UKT penuh setiap tahunnya hanya berkisar antara 30% \u2013 50% dari seluruh jumlah mahasiswa ITB, selebihnya mendapat pengurangan UKT yang besarnya berkisar antara 20% \u2013 100% dari nilai UKT yang harus dibayarkan (total, sekitar Rp. 135 M untuk subsidi UKT per tahun).", "Sekolah Bisnis dan Manajemen (SBM) ITB tidak menawarkan subsidi UKT bagi calon mahasiswa, kecuali calon mahasiswa yang mengikuti program Beasiswa Bidikmisi.", "Bisa. Program Peminatan ITB tidak terkait dengan pemberian beasiswa apa pun. Artinya setiap calon mahasiswa yang memilih ITB pada SNMPTN, termasuk calon mahasiswa peserta Beasiswa Bidikmisi, diperkenankan untuk mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan tahun 2018 dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB tidak terkait dengan pemberian beasiswa apa pun. Calon mahasiswa yang memilih salah satu (boleh memilih program studi lain di luar program peminatan) atau lebih dari satu program studi yang ditawarkan pada Program Peminatan ITB, tetap dikenai biaya pendidikan sesuai dengan ketentuan yang berlaku di ITB, bila lulus di salah satu program studi yang dipilihnya. Namun demikian, Program Peminatan ITB tidak membatasi calon mahasiswa untuk memperoleh beasiswa/subsidi biaya pendidikan dari sumber-sumber lain, termasuk Beasiswa Bidikmisi. Informasi selengkapnya mengenai Program Peminatan tahun 2018 dapat diperoleh di laman Program Peminatan. Sebagai informasi, jumlah mahasiswa ITB yang membayar UKT penuh setiap tahunnya hanya berkisar antara 30% \u2013 50% dari seluruh jumlah mahasiswa ITB, selebihnya mendapat pengurangan UKT yang besarnya berkisar antara 20% \u2013 100% dari nilai UKT yang harus dibayarkan (total, sekitar Rp. 135 M untuk subsidi UKT per tahun).", "Tidak. Sekolah Bisnis dan Manajemen (SBM) ITB tidak menawarkan subsidi UKT bagi calon mahasiswa, kecuali calon mahasiswa yang mengikuti program Beasiswa Bidikmisi.", "Informasi mengenai biaya perkuliahan bagi mahasiswa baru ITB Internasional Program dapat diperoleh di laman Tuition Fees.", "ITB tidak menyediakan beasiswa bagi mahasiswa ITB Internasional Program, baik bagi mahasiswa berkewarganegaraan asing mau pun bagi mahasiswa berkewarganegaraan Indonesia. Informasi mengenai biaya perkuliahan bagi mahasiswa ITB Internasional Program dapat diperoleh di laman Tuition Fees.", "Mulai tahun 2011, ITB menggunakan SNMPTN dan SBMPTN untuk melaksanakan seleksi mahasiswa baru program sarjana di semua Fakultas dan Sekolah di ITB. Selain dari pelaksanaan SNMPTN dan SBMPTN tersebut, ITB tidak menerima mahasiswa baru program sarjana melalui jalur seleksi lain. Sebagai informasi, silakan mengunjungi laman resmi SNMPTN 2015 (http://snmptn.ac.id/) atau laman resmi SBMPTN 2015 (http://sbmptn.or.id/) untuk memperoleh gambaran mengenai pelaksanaan pendaftaran dan seleksi mahasiswa baru di Perguruan Tinggi Negeri di Indonesia, termasuk ITB.", "ITB menggunakan SNMPTN dan SBMPTN untuk melaksanakan seleksi mahasiswa baru program sarjana di semua Fakultas dan Sekolah di ITB. Selain dari pelaksanaan SNMPTN dan SBMPTN tersebut, ITB tidak menerima mahasiswa baru program sarjana melalui jalur seleksi lain. Sebagai informasi, silakan mengunjungi laman resmi SNMPTN 2015 (http://snmptn.ac.id/) atau laman resmi SBMPTN 2015 (http://sbmptn.or.id/) untuk memperoleh gambaran mengenai pelaksanaan pendaftaran dan seleksi mahasiswa baru di Perguruan Tinggi Negeri di Indonesia, termasuk ITB.", "Bila saudara merupakan calon mahasiswa yang akan mengikuti UN pada tahun seleksi yang bersangkutan, silakan memilih ITB pada pelaksanaan SNMPTN. Seleksi mahasiswa baru melalui SNMPTN dilaksanakan dengan menggunakan pola penjaringan prestasi akademis calon mahasiswa di SLTA asalnya, tanpa melalui ujian seleksi. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "SNMPTN merupakan singkatan dari Seleksi Nasional Masuk Perguruan Tinggi Negeri, merupakan suatu sistem seleksi mahasiswa baru program sarjana untuk seluruh Perguruan Tinggi Negeri di Indonesia termasuk ITB, yang dilaksanakan secara nasional dengan menggunakan pola penjaringan prestasi akademis calon mahasiswa di SLTA asalnya. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "SNMPTN merupakan pola seleksi nasional berdasarkan penjaringan prestasi akademik dengan menggunakan nilai rapor dan prestasi-prestasi lainnya. Pada pelaksanaan SNMPTN, siswa tidak mengikuti ujian. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "Sekolah yang berhak mengikutsertakan siswanya dalam SNMPTN adalah sekolah yang mempunyai Nomor Pokok Sekolah Nasional (NPSN) dan yang mengisikan data prestasi siswa di Pangkalan Data Sekolah dan Siswa (PDSS). Siswa yang berhak mengikuti seleksi adalah siswa yang memiliki rekam jejak prestasi akademik di PDSS. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "Sekolah yang siswanya berhak mengikuti SNMPTN adalah SMA/SMK/MA/MAK negeri maupun swasta, termasuk sekolah RI di luar negeri, memiliki NPSN (Nomor Pokok Sekolah Nasional), telah mengisi PDSS, dan terdaftar sebagai peserta Ujian Nasional (UN) pada tahun yang bersangkutan.", "Sekolah yang siswanya berhak mengikuti SNMPTN adalah SMA/SMK/MA/MAK negeri maupun swasta, termasuk sekolah RI di luar negeri, yang telah memiliki NPSN (Nomor Pokok Sekolah Nasional) dan telah mengisi PDSS, serta terdaftar sebagai peserta Ujian Nasional (UN) pada tahun yang bersangkutan, terlepas dari ada atau tidaknya alumni sekolah tersebut di perguruan tinggi tujuan peserta.", "Untuk mengikuti SNMPTN, terdapat 2 tahap yang harus dilalui, yaitu tahap Pengisian PDSS di laman http://pdss.snmptn.ac.id/ dan tahap Pendaftaran. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "Pada pelaksanaan SNMPTN, seleksi dilaksanakan melalui rapor siswa yang telah diisikan sekolah di PDSS. Tidak ada ujian atau wawancara dalam bentuk apa pun pada pelaksanaan SNMPTN. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "Tidak ada batasan prestasi bagi siswa untuk mengikuti SNMPTN. Pada dasarnya, seluruh siswa yang akan mengikuti Ujian Nasional (UN) SLTA tahun berhak mengikuti SNMPTN, dengan catatan, siswa yang bersangkutan memiliki rekam jejak prestasi akademik di Pangkalan Data Sekolah dan Siswa (PDSS) SNMPTN. Informasi mengenai pelaksanaan SNMPTN 2015 dapat diperoleh di laman resmi SNMPTN 2015 (http://snmptn.ac.id/).", "Sehubungan adanya perbedaan kurikulum antara SMA/MA bidang IPA dan SMA/MA bidang IPS, pada pelaksanaan SNMPTN, ITB hanya menawarkan fakultas/sekolah bidang Sains dan Teknik bagi siswa yang berasal dari SMA/MA bidang IPA. Siswa dari SMA/MA bidang IPS dapat memilih FSRD ITB dan SBM ITB pada pelaksanaan SNMPTN. Bagi siswa SMA/MA bidang IPS yang berminat memilih fakultas/sekolah bidang Sains dan Teknik di ITB, dipersilakan mencoba memilih ITB pada pelaksanaan SBMPTN. Informasi selengkapnya dapat diperoleh di laman Ketentuan ITB pada Pelaksanaan SNMPTN 2015.", "Sehubungan adanya perbedaan kurikulum antara SMA/MA bidang IPA dan SMK, pada pelaksanaan SNMPTN, ITB hanya menawarkan fakultas/sekolah bidang Sains dan Teknik bagi siswa yang berasal dari SMA/MA bidang IPA. Siswa dari SMK hanya dapat memilih FSRD ITB pada pelaksanaan SNMPTN. Bagi siswa SMK yang berminat memilih fakultas/sekolah bidang Sains dan Teknik atau SBM di ITB, dipersilakan mencoba memilih ITB pada pelaksanaan SBMPTN. Informasi selengkapnya dapat diperoleh di laman Ketentuan ITB pada Pelaksanaan SNMPTN 2015.", "Tidak, saudara tetap harus mengikuti salah satu program seleksi mahasiswa baru ITB (SNMPTN atau SBMPTN). Prestasi saudara di akan dipertimbangkan sebagai nilai tambah pada program seleksi yang saudara ikuti.", "Setiap Siswa Pendaftar dapat memilih sebanyak-banyaknya 2 (dua) PTN. Apabila memilih 2 (dua) PTN, maka salah satu PTN harus berada di provinsi yang sama dengan SMA asalnya. Apabila memilih satu PTN, maka PTN yang dipilih dapat berada di provinsi mana pun. Siswa Pendaftar dapat memilih sebanyak-banyaknya 3 (tiga) program studi dengan ketentuan satu PTN maksimal 2 (dua) program studi. Urutan pilihan PTN dan program studi menyatakan prioritas pilihan.", "Daftar program studi dan daya tampung SNMPTN tahun 2015 dapat dilihat pada laman http://www.snmptn.ac.id selama periode pendaftaran. Selain itu, ITB menyediakan informasi mengenai Tingkat Kesulitan Relatif dari Fakultas/Sekolah yang ditawarkan ITB pada pelaksanaan SNMPTN di laman Tingkat Kesulitan Relatif.", "Pada pelaksanaan SNMPTN, ITB membuka program peminatan bagi calon mahasiswa yang benar-benar berminat untuk memilih beberapa program studi tertentu. Pada tahun 2015, terdapat 14 program studi yang ditawarkan pada program peminatan tersebut di SNMPTN 2015, yaitu Astronomi (FMIPA), Rekayasa Pertanian (SITH-Program Rekayasa), Rekayasa Kehutanan (SITH-Program Rekayasa), Teknologi Pasca Panen (SITH-Program Rekayasa), Meteorologi (FITB), Oseanografi (FITB), Teknik Pertambangan (FTTM), Teknik Fisika (FTI-Kampus Ganesa), Manajemen Rekayasa Industri (FTI-Kampus Ganesa), Teknik Material (FTMD), Teknik Telekomunikasi (STEI), Teknik Biomedis (STEI), Perencanaan Wilayah dan Kota (SAPPK), Kewirausahaan (SBM), dan/atau Kelas Internasional Program Studi Manajemen (SBM). Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Pada pelaksanaan SNMPTN, ITB membuka program peminatan bagi calon mahasiswa yang benar-benar berminat untuk memilih beberapa program studi tertentu. Program studi yang ditawarkan ITB pada program peminatan adalah program studi yang bidang keahliannya masih kurang dikenal di masyarakat, namun sebenarnya sangat dibutuhkan di dunia industri. Pada tahun 2015, terdapat 14 program studi yang ditawarkan pada program peminatan tersebut di SNMPTN 2015, yaitu Astronomi (FMIPA), Rekayasa Pertanian (SITH-Program Rekayasa), Rekayasa Kehutanan (SITH-Program Rekayasa), Teknologi Pasca Panen (SITH-Program Rekayasa), Meteorologi (FITB), Oseanografi (FITB), Teknik Pertambangan (FTTM), Teknik Fisika (FTI-Kampus Ganesa), Manajemen Rekayasa Industri (FTI-Kampus Ganesa), Teknik Material (FTMD), Teknik Telekomunikasi (STEI), Teknik Biomedis (STEI), Perencanaan Wilayah dan Kota (SAPPK), Kewirausahaan (SBM), dan/atau Kelas Internasional Program Studi Manajemen (SBM). Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Untuk mengikuti program peminatan, calon mahasiswa tetap harus mengikuti SNMPTN dan memilih fakultas yang menaungi program studi yang diminatinya di ITB (Astronomi (FMIPA), Rekayasa Pertanian (SITH-Program Rekayasa), Rekayasa Kehutanan (SITH-Program Rekayasa), Teknologi Pasca Panen (SITH-Program Rekayasa), Meteorologi (FITB), Oseanografi (FITB), Teknik Pertambangan (FTTM), Teknik Fisika (FTI-Kampus Ganesa), Manajemen Rekayasa Industri (FTI-Kampus Ganesa), Teknik Material (FTMD), Teknik Telekomunikasi (STEI), Teknik Biomedis (STEI), Perencanaan Wilayah dan Kota (SAPPK), Kewirausahaan (SBM), dan/atau Kelas Internasional Program Studi Manajemen (SBM)) pada laman SNMPTN (http://web.snmptn.ac.id/). Calon mahasiswa kemudian diharuskan untuk menyerahkan Formulir Pilihan Program Studi ITB yang telah diisi lengkap ke ITB. Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Bukan. Program Peminatan ITB merupakan bagian dari pelaksanaan SNMPTN di ITB. Calon mahasiswa yang tidak mengikuti SNMPTN atau tidak memilih ITB di SNMPTN, tidak dapat mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB merupakan bagian dari pelaksanaan SNMPTN di ITB. Calon mahasiswa yang tidak mengikuti SNMPTN atau tidak memilih ITB di SNMPTN, tidak dapat mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB merupakan bagian dari pelaksanaan SNMPTN di ITB. Calon mahasiswa yang tidak mengikuti SNMPTN atau tidak memilih ITB di SNMPTN, tidak dapat mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Bisa, bila saudara mengirimkan konfirmasi pembatalan sebelum batas waktu pengiriman formulir Program Peminatan ITB berakhir. Setelah batas waktu tersebut terlewati, data saudara telah dikunci dan keikutsertaan anda di Program Peminatan ITB tidak dapat dibatalkan.", "Tidak bisa. Calon mahasiswa ITB hanya dapat mendaftarkan diri dan melanjutkan studi di Fakultas/Sekolah/Program Studi tempat calon yang bersangkutan dinyatakan diterima. Dengan demikian, sehubungan dengan penerimaan saudara di salah satu program studi yang saudara pilih melalui Program Peminatan ITB, saudara hanya dapat mendaftarkan diri dan melanjutkan studi di program studi tersebut serta tidak dapat membatalkan keikutsertaan saudara pada Program Peminatan ITB.", "Bisa. Program Peminatan ITB tidak terkait dengan pemberian beasiswa apa pun. Artinya setiap calon mahasiswa yang memilih ITB pada SNMPTN, termasuk calon mahasiswa peserta Beasiswa Bidikmisi, diperkenankan untuk mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB tidak terkait dengan pemberian beasiswa apa pun. Calon mahasiswa yang memilih salah satu (boleh memilih program studi lain di luar program peminatan) atau lebih dari satu program studi yang ditawarkan pada Program Peminatan ITB, tetap dikenai biaya pendidikan sesuai dengan ketentuan yang berlaku di ITB, bila lulus di salah satu program studi yang dipilihnya. Namun demikian, Program Peminatan ITB tidak membatasi calon mahasiswa untuk memperoleh beasiswa/subsidi biaya pendidikan dari sumber-sumber lain, termasuk Beasiswa Bidikmisi. Informasi selengkapnya mengenai Program Peminatan tahun 2015 dapat diperoleh di laman Program Peminatan.", "Tidak. Sekolah Bisnis dan Manajemen (SBM) ITB tidak menawarkan subsidi UKT bagi calon mahasiswa, kecuali calon mahasiswa yang mengikuti program Beasiswa Bidikmisi.", "Informasi dan ketentuan mengenai Kelas Internasional Manajemen (SBM) dapat saudara peroleh di laman http://sbm.itb.ac.id. Silakan mempelajari informasi tersebut secara teliti.", "Tata cara pemilihan program studi peminatan pada pelaksanaan SNMPTN dan tata cara pengisian formulir peminatan telah tercantum di laman Program Peminatan. Silakan mempelajari informasi tersebut secara teliti.", "Tidak, peserta SNMPTN 2015 tidak diperkenankan untuk memilih lebih dari 1 program studi dalam fakultas/sekolah yang sama pada pelaksanaan program peminatan. Formulir peminatan yang tidak diisi sesuai dengan ketentuan di atas tidak akan diproses lebih lanjut oleh ITB. Tata cara pemilihan program studi peminatan pada pelaksanaan SNMPTN dan tata cara pengisian formulir peminatan telah tercantum di laman Program Peminatan. Silakan mempelajari informasi tersebut secara teliti.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Memang benar terdapat 2 program studi baru di ITB yang tidak ditawarkan pada pelaksanaan program peminatan ITB 2015, yaitu program studi Teknik Pangan (FTI-Kampus Jatinangor) serta program studi Teknik Bioenergi dan Kemurgi (FTI-Kampus Jatinangor). Selain itu, ITB tidak lagi menawarkan program studi Rekayasa Infrastruktur Lingkungan (FTSL-Kampus Jatinangor) serta program studi Teknik Pengelolaan Sumber Daya Air (FTSL-Kampus Jatinangor) pada program peminatan ITB 2015. Peminat keempat program studi tersebut dapat memilih pilihan FTI-Kampus Jatinangor dan/atau FTSL-Kampus Jatinangor pada pelaksanaan SNMPTN 2015 tanpa menggunakan formulir peminatan. Saat ini pilihan FTI-Kampus Jatinangor serta FTSL-Kampus Jatinangor masih menunggu nomor kode pilihan program studi dari Panitia SNMPTN 2015. Informasi selengkapnya mengenai pilihan program studi tersebut dapat saudara peroleh di laman Pilihan Program Studi di ITB.", "Tidak, saudara tetap harus mengikuti salah satu program seleksi mahasiswa baru ITB (SNMPTN atau SBMPTN). Prestasi saudara di akan dipertimbangkan sebagai nilai tambah pada program seleksi yang saudara ikuti.", "Pada pelaksanaan SNMPTN, ITB membuka program peminatan bagi calon mahasiswa yang benar-benar berminat untuk memilih beberapa program studi tertentu. Pada tahun 2017, terdapat 14 program studi yang ditawarkan pada program peminatan tersebut di SNMPTN. Informasi selengkapnya mengenai Program Peminatan tahun 207 dapat diperoleh di laman Program Peminatan.", "Pada pelaksanaan SNMPTN, ITB membuka program peminatan bagi calon mahasiswa yang benar-benar berminat untuk memilih beberapa program studi tertentu. Program studi yang ditawarkan ITB pada program peminatan adalah program studi yang bidang keahliannya masih kurang dikenal di masyarakat, namun sebenarnya sangat dibutuhkan di dunia industri. Pada tahun 2017, terdapat 14 program studi yang ditawarkan pada program peminatan tersebut di SNMPTN 2017. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Untuk mengikuti program peminatan, calon mahasiswa tetap harus mengikuti SNMPTN dan memilih fakultas yang menaungi program studi yang diminatinya di ITB pada laman SNMPTN (http://web.snmptn.ac.id/). Calon mahasiswa kemudian diharuskan untuk mendaftarkan diri secara online di laman Pendaftaran Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Bukan. Program Peminatan ITB merupakan bagian dari pelaksanaan SNMPTN di ITB. Calon mahasiswa yang tidak mengikuti SNMPTN atau tidak memilih ITB di SNMPTN, tidak dapat mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB merupakan bagian dari pelaksanaan SNMPTN di ITB. Calon mahasiswa yang tidak mengikuti SNMPTN atau tidak memilih ITB di SNMPTN, tidak dapat mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB merupakan bagian dari pelaksanaan SNMPTN di ITB. Calon mahasiswa yang tidak mengikuti SNMPTN atau tidak memilih ITB di SNMPTN, tidak dapat mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Bisa, bila saudara melakukan pembatalan sebelum batas waktu pendaftaran Program Peminatan ITB berakhir. Setelah batas waktu tersebut terlewati, data saudara telah dikunci dan keikutsertaan anda di Program Peminatan ITB tidak dapat dibatalkan.", "Tidak bisa. Calon mahasiswa ITB hanya dapat mendaftarkan diri dan melanjutkan studi di Fakultas/Sekolah/Program Studi tempat calon yang bersangkutan dinyatakan diterima. Dengan demikian, sehubungan dengan penerimaan saudara di salah satu program studi yang saudara pilih melalui Program Peminatan ITB, saudara hanya dapat mendaftarkan diri dan melanjutkan studi di program studi tersebut serta tidak dapat membatalkan keikutsertaan saudara pada Program Peminatan ITB.", "Bisa. Program Peminatan ITB tidak terkait dengan pemberian beasiswa apa pun. Artinya setiap calon mahasiswa yang memilih ITB pada SNMPTN, termasuk calon mahasiswa peserta Beasiswa Bidikmisi, diperkenankan untuk mengikuti Program Peminatan ITB. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Tidak. Program Peminatan ITB tidak terkait dengan pemberian beasiswa apa pun. Calon mahasiswa yang memilih salah satu (boleh memilih program studi lain di luar program peminatan) atau lebih dari satu program studi yang ditawarkan pada Program Peminatan ITB, tetap dikenai biaya pendidikan sesuai dengan ketentuan yang berlaku di ITB, bila lulus di salah satu program studi yang dipilihnya. Namun demikian, Program Peminatan ITB tidak membatasi calon mahasiswa untuk memperoleh beasiswa/subsidi biaya pendidikan dari sumber-sumber lain, termasuk Beasiswa Bidikmisi. Informasi selengkapnya mengenai Program Peminatan dapat diperoleh di laman Program Peminatan.", "Tidak. Sekolah Bisnis dan Manajemen (SBM) ITB tidak menawarkan subsidi UKT bagi calon mahasiswa, kecuali calon mahasiswa yang mengikuti program Beasiswa Bidikmisi.", "Informasi dan ketentuan mengenai Kelas Internasional Manajemen (SBM) dapat saudara peroleh di laman http://sbm.itb.ac.id. Silakan mempelajari informasi tersebut secara teliti.", "Tata cara pemilihan program studi peminatan pada pelaksanaan SNMPTN dan tata cara pendaftaran online telah tercantum di laman Program Peminatan. Silakan mempelajari informasi tersebut secara teliti.", "Tidak, peserta SNMPTN tidak diperkenankan untuk memilih lebih dari 1 program studi dalam fakultas/sekolah yang sama pada pelaksanaan program peminatan. Pemilihan program studi peminatan yang tidak diisi sesuai dengan ketentuan di atas tidak akan diproses lebih lanjut oleh sistem pendaftaran program peminatan ITB. Tata cara pemilihan program studi peminatan pada pelaksanaan SNMPTN dan tata cara pengisian formulir peminatan telah tercantum di laman Program Peminatan. Silakan mempelajari informasi tersebut secara teliti.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Saudara tidak dapat melakukan pemilihan tersebut. Pada pelaksanaan SNMPTN, ITB menerima mahasiswa baru di Fakultas/Sekolah. Program peminatan hanya merupakan pelengkap dari pelaksanaan SNMPTN di ITB. Bila saudara ingin memilih satu program studi peminatan dan program studi lain yang tidak ditawarkan ITB pada program peminatan dalam Fakultas/Sekolah yang sama, ITB menyarankan agar saudara tidak perlu mengikuti program peminatan. Pemilihan program studi yang saudara inginkan dapat saudara laksanakan pada tahun pertama perkuliahan di ITB, bila saudara dinyatakan diterima di fakultas/sekolah yang bersangkutan.", "Memang benar terdapat 2 program studi baru di ITB yang tidak ditawarkan pada pelaksanaan program peminatan ITB, yaitu program studi Teknik Pangan (FTI-Kampus Jatinangor) serta program studi Teknik Bioenergi dan Kemurgi (FTI-Kampus Jatinangor). Selain itu, ITB tidak lagi menawarkan program studi Rekayasa Infrastruktur Lingkungan (FTSL-Kampus Jatinangor) serta program studi Teknik Pengelolaan Sumber Daya Air (FTSL-Kampus Jatinangor) pada program peminatan ITB. Peminat keempat program studi tersebut dapat memilih pilihan FTI-Kampus Jatinangor dan/atau FTSL-Kampus Jatinangor pada pelaksanaan SNMPTN tanpa mengikuti program peminatan ITB. Informasi selengkapnya mengenai pilihan program studi tersebut dapat saudara peroleh di laman Pilihan Program Studi di ITB.", "Bagi calon mahasiswa yang dinyatakan diterima di ITB melalui Program Peminatan ITB, setelah tahun pertama perkuliahan (TPB), mahasiswa akan ditempatkan di program studi yang menerimanya pada Program Peminatan ITB, dan tidak diperkenankan untuk mengajukan perpindahan program studi.", "Bagi calon mahasiswa yang dinyatakan diterima di ITB melalui Program Peminatan ITB, setelah tahun pertama perkuliahan (TPB), mahasiswa akan ditempatkan di program studi yang menerimanya pada Program Peminatan ITB, dan tidak diperkenankan untuk mengajukan perpindahan program studi.", "SBMPTN merupakan singkatan dari Seleksi Bersama Masuk Perguruan Tinggi Negeri, merupakan suatu sistem seleksi mahasiswa baru program sarjana untuk seluruh Perguruan Tinggi Negeri di Indonesia termasuk ITB, yang dilaksanakan secara bersama dengan menggunakan pola seleksi berdasarkan hasil ujian tertulis. Sebagai informasi pelaksanaan SBMPTN 2016, silakan mengunjungi laman resmi SBMPTN 2016 (http://sbmptn.ac.id/).", "SBMPTN merupakan sistem ujian saringan masuk perguruan tinggi negeri yang dilaksanakan secara nasional, oleh sebuah panitia terpusat yang ditunjuk oleh Majelis Rektor Perguruan Tinggi Negeri Indonesia (MRPTNI). Ujian tertulis SBMPTN dilaksanakan secara serentak dan terpadu pada jam dan hari yang sama, dengan soal yang sama di berbagai wilayah di Indonesia, sehingga peserta diharapkan dapat memilih lokasi yang terdekat dengan penyelenggaraan kegiatan seleksi tersebut. Tempat ujian tidak menjadi bahan pertimbangan dalam proses seleksi dan penentuan kelulusan seorang calon mahasiswa di perguruan tinggi negeri yang dipilihnya. Sebagai informasi pelaksanaan SBMPTN 2016, silakan mengunjungi laman resmi SBMPTN 2016 (http://sbmptn.ac.id/).", "Peserta SBMPTN harus lulus dari Satuan Pendidikan dan Ujian Nasional SMA/MA/SMK/MAK atau yang setara dengan 3 tahun terakhir dan telah memiliki ijazah SMA/MA/SMK/MAK atau yang setara. Untuk lulusan tahun berjalan sekurang-kurangnya telah memiliki Surat Keterangan Hasil Ujian Nasional (SKHUN) dari Kepala Sekolah yang dilengkapi dengan pasfoto terbaru yang bersangkutan dan dibubuhi cap sekolah. Peserta yang bersangkutan juga harus memenuhi persyaratan yang berlaku di program studi tujuannya. Sebagai informasi pelaksanaan SBMPTN 2016, silakan mengunjungi laman resmi SBMPTN 2016 (http://sbmptn.ac.id/).", "Peserta SBMPTN harus lulus dari Satuan Pendidikan dan Ujian Nasional SMA/MA/SMK/MAK atau yang setara dengan 3 tahun terakhir dan telah memiliki ijazah SMA/MA/SMK/MAK atau yang setara. Khusus bagi peserta Paket C, hanya dapat mengikuti SBMPTN bila telah memiliki Ijazah Paket C. Bila nilai Paket C belum terbit pada saat pelaksanaan SBMPTN tahun berjalan, silakan mengikuti SBMPTN pada tahun yang akan datang. Sebagai informasi pelaksanaan SBMPTN 2016, silakan mengunjungi laman resmi SBMPTN 2016 (http://sbmptn.ac.id/).", "Seleksi penerimaan mahasiswa baru ITB dilaksanakan melalui SNMPTN dan SBMPTN. Dengan demikian persyaratan untuk mengikuti seleksi mahasiswa baru ITB yang berlaku adalah persyaratan peserta SNMPTN dan/atau SBMPTN, yang salah satunya adalah telah lulus UN SLTA atau Paket C, dibuktikan dengan Surat Keterangan Hasil Ujian Nasional atau Surat Keterangan Lulus Paket C. Sebagai gambaran, informasi mengenai persyaratan peserta SBMPTN 2016 dapat diperoleh di laman resmi SBMPTN 2016 (http://sbmptn.ac.id/).", "Seleksi penerimaan mahasiswa baru ITB dilaksanakan melalui SNMPTN dan SBMPTN. Dengan demikian persyaratan untuk mengikuti seleksi mahasiswa baru ITB yang berlaku adalah persyaratan peserta SNMPTN dan/atau SBMPTN, yang salah satunya adalah telah lulus UN SLTA atau Paket C, dibuktikan dengan Surat Keterangan Hasil Ujian Nasional atau Surat Keterangan Lulus Paket C. Khusus bagi lulusan SLTA di luar wilayah Republik Indonesia dan bukan merupakan lulusan Sekolah Indonesia di Luar Negeri, saudara juga dapat menggunakan ijazah dari SLTA saudara yang dilengkapi dengan Surat Keterangan Penyetaraan Ijazah SLTA dari Kementerian Pendidikan dan Kebudayaan Republik Indonesia. Sebagai gambaran, informasi mengenai persyaratan peserta SBMPTN 2016 dapat diperoleh di laman resmi SBMPTN 2016 (http://sbmptn.ac.id/).", "Sesuai dengan informasi di laman resmi SBMPTN (http://sbmptn.ac.id), tempat pelaksanaan ujian tidak menjadi pertimbangan pada kelulusan SBMPTN. Dengan demikian saudara dapat mendaftar dan mengikuti SBMPTN di lokasi terdekat dengan tempat domisili anda.", "Sesuai dengan informasi di laman resmi SBMPTN (http://sbmptn.ac.id), pendaftaran SBMPTN dilaksanakan secara online di laman http://sbmptn.ac.id. Pendaftaran dapat dilakukan di mana saja di seluruh wilayah Indonesia, bahkan di Luar Negeri, dengan menggunakan akses internet.", "SBMPTN terdiri atas kelompok ujian SAINTEK, kelompok ujian SOSHUM, dan kelompok ujian CAMPURAN (mengikuti ujian ujian SAINTEK dan SOSHUM). Informasi mengenai materi yang diujikan di masing-masing kelompok ujian dapat diperoleh di lamanhttp://sbmptn.ac.id/.", "Peserta SBMPTN akan mengikuti kelompok ujian berdasar fakultas/sekolah/program studi yang dipilihnya, tanpa memperhatikan bidang studi asal SMA. Sebagai contoh, siswa yang berasal dari SMA IPA dapat memilih SBM ITB (kelompok ujian SOSHUM) serta harus mengikuti ujian dengan materi kelompok SOSHUM. Demikian pula sebaliknya, siswa SMA yang berasal dari IPS dapat memilih FTMD ITB (kelompok ujian SAINTEK) serta harus mengikuti ujian dengan materi kelompok SAINTEK. Informasi selengkapnya dapat diperoleh di laman http://sbmptn.ac.id/.", "Tidak bisa. Peserta SBMPTN akan mengikuti kelompok ujian berdasar fakultas/sekolah/program studi yang dipilihnya, tanpa memperhatikan bidang studi asal SMA. Sebagai contoh, siswa yang berasal dari SMA IPA dapat memilih SBM ITB (kelompok ujian SOSHUM) serta harus mengikuti ujian dengan materi kelompok SOSHUM. Demikian pula sebaliknya, siswa SMA yang berasal dari IPS dapat memilih FTMD ITB (kelompok ujian SAINTEK) serta harus mengikuti ujian dengan materi kelompok SAINTEK. Informasi selengkapnya dapat diperoleh di laman http://sbmptn.ac.id/.", "Pada pelaksanaan SBMPTN, beberapa fakultas/sekolah/program studi bidang Seni (seni rupa, desain, seni musik, seni drama, seni tari) serta bidang Olahraga mensyaratkan adanya ujian keterampilan bagi peserta SBMPTN yang memilihnya. Informasi selengkapnya mengenai pelaksanaan ujian keterampilan serta daftar fakultas/sekolah/program studi yang mensyaratkan ujian keterampilan dapat diperoleh di laman http://sbmptn.or.id/.", "Benar, FSRD ITB mensyaratkan Ujian Keterampilan Seni Rupa. Dengan demikian, pemilih FSRD ITB harus mengikuti ujian tertulis kelompok SOSHUM dan Ujian Keterampilan Seni Rupa. Informasi selengkapnya dapat diperoleh di laman http://sbmptn.ac.id/ dan di laman Pelaksanaan Ujian Keterampilan Seni Rupa SBMPTN 2016.", "Tidak, peserta SBMPTN yang memilih FSRD ITB dapat mengikuti Ujian Keterampilan Seni Rupa di PTN lain yang menyelenggarakan Ujian Keterampilan Seni Rupa, di lokasi terdekat dengan lokasi domisili peserta yang bersangkutan. Informasi selengkapnya dapat diperoleh di laman http://sbmptn.ac.id/ dan di laman Pelaksanaan Ujian Keterampilan Seni Rupa SBMPTN 2016.", "Tidak, Program Peminatan ITB hanya ditawarkan pada pelaksanaan SNMPTN saja dan tidak dibuka pada pelaksanaan SBMPTN.", "Sejak tahun 2011, ITB tidak melaksanakan seleksi penerimaan mahasiswa baru program sarjana melalui jalur seleksi secara mandiri. ITB hanya menerima mahasiswa baru program sarjana melalui SNMPTN dan SBMPTN. Sebagai informasi, silakan mengunjungi laman resmi SNMPTN 2015 (http://snmptn.ac.id/) atau laman resmi SBMPTN 2014 (http://sbmptn.or.id/) untuk memperoleh gambaran mengenai pelaksanaan pendaftaran dan seleksi mahasiswa baru di Perguruan Tinggi Negeri di Indonesia, termasuk ITB", "ITB hanya melakukan program seleksi mahasiswa transfer dengan beberapa perguruan tinggi yang telah menjalin kerjasama formal di bidang transfer mahasiswa (dibuktikan dengan MoU). Informasi selengkapnya mengenai sistem penerimaan mahasiswa baru ITB dapat diperoleh di alamat http://usm.itb.ac.id/.", "ITB hanya melakukan program seleksi mahasiswa transfer dengan beberapa perguruan tinggi yang telah menjalin kerjasama formal di bidang transfer mahasiswa (dibuktikan dengan MoU). Silakan menghubungi perguruan tinggi asal saudara untuk mengetahui keberadaan MoU kerja sama transfer mahasiswa dari perguruan tinggi tersebut ke ITB.", "Silakan menghubungi perguruan tinggi asal saudara untuk mengetahui keberadaan MoU kerja sama transfer mahasiswa dari perguruan tinggi tersebut ke ITB.", "ITB tidak memiliki program alih jenjang dari D3 ke S1 atau program-program keprofesian sejenis seperti yang saudara maksudkan di luar program S1, S2, dan S3 reguler. Informasi selengkapnya mengenai sistem penerimaan mahasiswa baru ITB dapat diperoleh di alamat http://usm.itb.ac.id/.", "ITB tidak memiliki program-program pendidikan jarak jauh sejenis seperti yang saudara maksudkan di luar program S1, S2, dan S3 reguler. Informasi selengkapnya mengenai sistem penerimaan mahasiswa baru ITB dapat diperoleh di alamat http://usm.itb.ac.id/.", "ITB tidak memiliki program-program keprofesian sejenis seperti yang saudara maksudkan di luar program S1, S2, dan S3 reguler. Informasi selengkapnya mengenai sistem penerimaan mahasiswa baru ITB dapat diperoleh di alamat http://usm.itb.ac.id/.", "ITB tidak memiliki program-program keprofesian sejenis seperti yang saudara maksudkan di luar program S1, S2, dan S3 reguler. Informasi selengkapnya mengenai sistem penerimaan mahasiswa baru ITB dapat diperoleh di alamat http://usm.itb.ac.id/.", "Python is an interpreted, interactive, object-oriented programming language. It incorporates modules, exceptions, dynamic typing, very high level dynamic data types, and classes. Python combines remarkable power with very clear syntax. It has interfaces to many system calls and libraries, as well as to various window systems, and is extensible in C or C++. It is also usable as an extension language for applications that need a programmable interface. Finally, Python is portable: it runs on many Unix variants, on the Mac, and on Windows 2000 and later.\nTo find out more, start with The Python Tutorial. The Beginner\u2019s Guide to Python links to other introductory tutorials and resources for learning Python.\n", "The Python Software Foundation is an independent non-profit organization that holds the copyright on Python versions 2.1 and newer. The PSF\u2019s mission is to advance open source technology related to the Python programming language and to publicize the use of Python. The PSF\u2019s home page is at https://www.python.org/psf/.\nDonations to the PSF are tax-exempt in the US. If you use Python and find it helpful, please contribute via the PSF donation page.\n", "You can do anything you want with the source, as long as you leave the copyrights in and display those copyrights in any documentation about Python that you produce. If you honor the copyright rules, it\u2019s OK to use Python for commercial use, to sell copies of Python in source or binary form (modified or unmodified), or to sell products that incorporate Python in some form. We would still like to know about all commercial use of Python, of course.\nSee the PSF license page to find further explanations and a link to the full text of the license.\nThe Python logo is trademarked, and in certain cases permission is required to use it. Consult the Trademark Usage Policy for more information.\n", "Here\u2019s a very brief summary of what started it all, written by Guido van Rossum:\nI had extensive experience with implementing an interpreted language in the ABC group at CWI, and from working with this group I had learned a lot about language design. This is the origin of many Python features, including the use of indentation for statement grouping and the inclusion of very-high-level data types (although the details are all different in Python).\nI had a number of gripes about the ABC language, but also liked many of its features. It was impossible to extend the ABC language (or its implementation) to remedy my complaints \u2013 in fact its lack of extensibility was one of its biggest problems. I had some experience with using Modula-2+ and talked with the designers of Modula-3 and read the Modula-3 report. Modula-3 is the origin of the syntax and semantics used for exceptions, and some other Python features.\nI was working in the Amoeba distributed operating system group at CWI. We needed a better way to do system administration than by writing either C programs or Bourne shell scripts, since Amoeba had its own system call interface which wasn\u2019t easily accessible from the Bourne shell. My experience with error handling in Amoeba made me acutely aware of the importance of exceptions as a programming language feature.\nIt occurred to me that a scripting language with a syntax like ABC but with access to the Amoeba system calls would fill the need. I realized that it would be foolish to write an Amoeba-specific language, so I decided that I needed a language that was generally extensible.\nDuring the 1989 Christmas holidays, I had a lot of time on my hand, so I decided to give it a try. During the next year, while still mostly working on it in my own time, Python was used in the Amoeba project with increasing success, and the feedback from colleagues made me add many early improvements.\nIn February 1991, after just over a year of development, I decided to post to USENET. The rest is in the Misc/HISTORY file.\n", "Python is a high-level general-purpose programming language that can be applied to many different classes of problems.\nThe language comes with a large standard library that covers areas such as string processing (regular expressions, Unicode, calculating differences between files), Internet protocols (HTTP, FTP, SMTP, XML-RPC, POP, IMAP, CGI programming), software engineering (unit testing, logging, profiling, parsing Python code), and operating system interfaces (system calls, filesystems, TCP/IP sockets). Look at the table of contents for The Python Standard Library to get an idea of what\u2019s available. A wide variety of third-party extensions are also available. Consult the Python Package Index to find packages of interest to you.\n", "Python versions are numbered A.B.C or A.B. A is the major version number \u2013 it is only incremented for really major changes in the language. B is the minor version number, incremented for less earth-shattering changes. C is the micro-level \u2013 it is incremented for each bugfix release. See PEP 6 for more information about bugfix releases.\nNot all releases are bugfix releases. In the run-up to a new major release, a series of development releases are made, denoted as alpha, beta, or release candidate. Alphas are early releases in which interfaces aren\u2019t yet finalized; it\u2019s not unexpected to see an interface change between two alpha releases. Betas are more stable, preserving existing interfaces but possibly adding new modules, and release candidates are frozen, making no changes except as needed to fix critical bugs.\nAlpha, beta and release candidate versions have an additional suffix. The suffix for an alpha version is \u201caN\u201d for some small number N, the suffix for a beta version is \u201cbN\u201d for some small number N, and the suffix for a release candidate version is \u201ccN\u201d for some small number N. In other words, all versions labeled 2.0aN precede the versions labeled 2.0bN, which precede versions labeled 2.0cN, and those precede 2.0.\nYou may also find version numbers with a \u201c+\u201d suffix, e.g. \u201c2.2+\u201d. These are unreleased versions, built directly from the CPython development repository. In practice, after a final minor release is made, the version is incremented to the next minor version, which becomes the \u201ca0\u201d version, e.g. \u201c2.4a0\u201d.\nSee also the documentation for sys.version, sys.hexversion, and sys.version_info.\n", "The latest Python source distribution is always available from python.org, at https://www.python.org/downloads/. The latest development sources can be obtained at https://github.com/python/cpython/.\nThe source distribution is a gzipped tar file containing the complete C source, Sphinx-formatted documentation, Python library modules, example programs, and several useful pieces of freely distributable software. The source will compile and run out of the box on most UNIX platforms.\nConsult the Getting Started section of the Python Developer\u2019s Guide for more information on getting the source code and compiling it.\n", "The standard documentation for the current stable version of Python is available at https://docs.python.org/3/. PDF, plain text, and downloadable HTML versions are also available at https://docs.python.org/3/download.html.\nThe documentation is written in reStructuredText and processed by the Sphinx documentation tool. The reStructuredText source for the documentation is part of the Python source distribution.\n", "There are numerous tutorials and books available. The standard documentation includes The Python Tutorial.\nConsult the Beginner\u2019s Guide to find information for beginning Python programmers, including lists of tutorials.\n", "There is a newsgroup, comp.lang.python, and a mailing list, python-list. The newsgroup and mailing list are gatewayed into each other \u2013 if you can read news it\u2019s unnecessary to subscribe to the mailing list. comp.lang.python is high-traffic, receiving hundreds of postings every day, and Usenet readers are often more able to cope with this volume.\nAnnouncements of new software releases and events can be found in comp.lang.python.announce, a low-traffic moderated list that receives about five postings per day. It\u2019s available as the python-announce mailing list.\nMore info about other mailing lists and newsgroups can be found at https://www.python.org/community/lists/.\n", "Alpha and beta releases are available from https://www.python.org/downloads/. All releases are announced on the comp.lang.python and comp.lang.python.announce newsgroups and on the Python home page at https://www.python.org/; an RSS feed of news is available.\nYou can also access the development version of Python through Git. See The Python Developer\u2019s Guide for details.\n", "To report a bug or submit a patch, please use the Roundup installation at https://bugs.python.org/.\nYou must have a Roundup account to report bugs; this makes it possible for us to contact you if we have follow-up questions. It will also enable Roundup to send you updates as we act on your bug. If you had previously used SourceForge to report bugs to Python, you can obtain your Roundup password through Roundup\u2019s password reset procedure.\nFor more information on how Python is developed, consult the Python Developer\u2019s Guide.\n", "It\u2019s probably best to cite your favorite book about Python.\nThe very first article about Python was written in 1991 and is now quite outdated.\nGuido van Rossum and Jelke de Boer, \u201cInteractively Testing Remote Servers Using the Python Programming Language\u201d, CWI Quarterly, Volume 4, Issue 4 (December 1991), Amsterdam, pp 283\u2013303.\n", "Yes, there are many, and more are being published. See the python.org wiki at https://wiki.python.org/moin/PythonBooks for a list.\nYou can also search online bookstores for \u201cPython\u201d and filter out the Monty Python references; or perhaps search for \u201cPython\u201d and \u201clanguage\u201d.\n", "The Python project\u2019s infrastructure is located all over the world and is managed by the Python Infrastructure Team. Details here.\n", "When he began implementing Python, Guido van Rossum was also reading the published scripts from \u201cMonty Python\u2019s Flying Circus\u201d, a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python.\n", "No, but it helps. :)\n", "Very stable. New, stable releases have been coming out roughly every 6 to 18 months since 1991, and this seems likely to continue. Currently there are usually around 18 months between major releases.\nThe developers issue \u201cbugfix\u201d releases of older versions, so the stability of existing releases gradually improves. Bugfix releases, indicated by a third component of the version number (e.g. 3.5.3, 3.6.2), are managed for stability; only fixes for known problems are included in a bugfix release, and it\u2019s guaranteed that interfaces will remain the same throughout a series of bugfix releases.\nThe latest stable releases can always be found on the Python download page. There are two production-ready versions of Python: 2.x and 3.x. The recommended version is 3.x, which is supported by most widely used libraries. Although 2.x is still widely used, it will not be maintained after January 1, 2020.\n", "There are probably tens of thousands of users, though it\u2019s difficult to obtain an exact count.\nPython is available for free download, so there are no sales figures, and it\u2019s available from many different sites and packaged with many Linux distributions, so download statistics don\u2019t tell the whole story either.\nThe comp.lang.python newsgroup is very active, but not all Python users post to the group or even read it.\n", "See https://www.python.org/about/success for a list of projects that use Python. Consulting the proceedings for past Python conferences will reveal contributions from many different companies and organizations.\nHigh-profile Python projects include the Mailman mailing list manager and the Zope application server. Several Linux distributions, most notably Red Hat, have written part or all of their installer and system administration software in Python. Companies that use Python internally include Google, Yahoo, and Lucasfilm Ltd.\n", "See https://www.python.org/dev/peps/ for the Python Enhancement Proposals (PEPs). PEPs are design documents describing a suggested new feature for Python, providing a concise technical specification and a rationale. Look for a PEP titled \u201cPython X.Y Release Schedule\u201d, where X.Y is a version that hasn\u2019t been publicly released yet.\nNew development is discussed on the python-dev mailing list.\n", "In general, no. There are already millions of lines of Python code around the world, so any change in the language that invalidates more than a very small fraction of existing programs has to be frowned upon. Even if you can provide a conversion program, there\u2019s still the problem of updating all documentation; many books have been written about Python, and we don\u2019t want to invalidate them all at a single stroke.\nProviding a gradual upgrade path is necessary if a feature has to be changed. PEP 5 describes the procedure followed for introducing backward-incompatible changes while minimizing disruption for users.\n", "Yes.\nIt is still common to start students with a procedural and statically typed language such as Pascal, C, or a subset of C++ or Java. Students may be better served by learning Python as their first language. Python has a very simple and consistent syntax and a large standard library and, most importantly, using Python in a beginning programming course lets students concentrate on important programming skills such as problem decomposition and data type design. With Python, students can be quickly introduced to basic concepts such as loops and procedures. They can probably even work with user-defined objects in their very first course.\nFor a student who has never programmed before, using a statically typed language seems unnatural. It presents additional complexity that the student must master and slows the pace of the course. The students are trying to learn to think like a computer, decompose problems, design consistent interfaces, and encapsulate data. While learning to use a statically typed language is important in the long term, it is not necessarily the best topic to address in the students\u2019 first programming course.\nMany other aspects of Python make it a good first language. Like Java, Python has a large standard library so that students can be assigned programming projects very early in the course that do something. Assignments aren\u2019t restricted to the standard four-function calculator and check balancing programs. By using the standard library, students can gain the satisfaction of working on realistic applications as they learn the fundamentals of programming. Using the standard library also teaches students about code reuse. Third-party modules such as PyGame are also helpful in extending the students\u2019 reach.\n", "Yes.\nThe pdb module is a simple but adequate console-mode debugger for Python. It is part of the standard Python library, and is documented in the Library Reference Manual. You can also write your own debugger by using the code for pdb as an example.\nThe IDLE interactive development environment, which is part of the standard Python distribution (normally available as Tools/scripts/idle), includes a graphical debugger.\nPythonWin is a Python IDE that includes a GUI debugger based on pdb. The Pythonwin debugger colors breakpoints and has quite a few cool features such as debugging non-Pythonwin programs. Pythonwin is available as part of the Python for Windows Extensions project and as a part of the ActivePython distribution (see https://www.activestate.com/activepython).\nBoa Constructor is an IDE and GUI builder that uses wxWidgets. It offers visual frame creation and manipulation, an object inspector, many views on the source like object browsers, inheritance hierarchies, doc string generated html documentation, an advanced debugger, integrated help, and Zope support.\nEric is an IDE built on PyQt and the Scintilla editing component.\nPydb is a version of the standard Python debugger pdb, modified for use with DDD (Data Display Debugger), a popular graphical debugger front end. Pydb can be found at http://bashdb.sourceforge.net/pydb/ and DDD can be found at https://www.gnu.org/software/ddd.\nThere are a number of commercial Python IDEs that include graphical debuggers. They include:\nWing IDE (https://wingware.com/)\nKomodo IDE (https://komodoide.com/)\nPyCharm (https://www.jetbrains.com/pycharm/)\n", "Yes.\nPyChecker is a static analysis tool that finds bugs in Python source code and warns about code complexity and style. You can get PyChecker from http://pychecker.sourceforge.net/.\nPylint is another tool that checks if a module satisfies a coding standard, and also makes it possible to write plug-ins to add a custom feature. In addition to the bug checking that PyChecker performs, Pylint offers some additional features such as checking line length, whether variable names are well-formed according to your coding standard, whether declared interfaces are fully implemented, and more. https://docs.pylint.org/ provides a full list of Pylint\u2019s features.\nStatic type checkers such as Mypy, Pyre, and Pytype can check type hints in Python source code.\n", "You don\u2019t need the ability to compile Python to C code if all you want is a stand-alone program that users can download and run without having to install the Python distribution first. There are a number of tools that determine the set of modules required by a program and bind these modules together with a Python binary to produce a single executable.\nOne is to use the freeze tool, which is included in the Python source tree as Tools/freeze. It converts Python byte code to C arrays; a C compiler you can embed all your modules into a new program, which is then linked with the standard Python modules.\nIt works by scanning your source recursively for import statements (in both forms) and looking for the modules in the standard Python path as well as in the source directory (for built-in modules). It then turns the bytecode for modules written in Python into C code (array initializers that can be turned into code objects using the marshal module) and creates a custom-made config file that only contains those built-in modules which are actually used in the program. It then compiles the generated C code and links it with the rest of the Python interpreter to form a self-contained binary which acts exactly like your script.\nObviously, freeze requires a C compiler. There are several other utilities which don\u2019t. One is Thomas Heller\u2019s py2exe (Windows only) at\nhttp://www.py2exe.org/\nAnother tool is Anthony Tuininga\u2019s cx_Freeze.\n", "Yes. The coding style required for standard library modules is documented as PEP 8.\n", "It can be a surprise to get the UnboundLocalError in previously working code when it is modified by adding an assignment statement somewhere in the body of a function.\nThis code:\n>>> x = 10\n>>> def bar():\n...     print(x)\n>>> bar()\n10\nworks, but this code:\n>>> x = 10\n>>> def foo():\n...     print(x)\n...     x += 1\nresults in an UnboundLocalError:\n>>> foo()\nTraceback (most recent call last):\n  ...\nUnboundLocalError: local variable 'x' referenced before assignment\nThis is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope. Since the last statement in foo assigns a new value to x, the compiler recognizes it as a local variable. Consequently when the earlier print(x) attempts to print the uninitialized local variable and an error results.\nIn the example above you can access the outer scope variable by declaring it global:\n>>> x = 10\n>>> def foobar():\n...     global x\n...     print(x)\n...     x += 1\n>>> foobar()\n10\nThis explicit declaration is required in order to remind you that (unlike the superficially analogous situation with class and instance variables) you are actually modifying the value of the variable in the outer scope:\n>>> print(x)\n11\nYou can do a similar thing in a nested scope using the nonlocal keyword:\n>>> def foo():\n...    x = 10\n...    def bar():\n...        nonlocal x\n...        print(x)\n...        x += 1\n...    bar()\n...    print(x)\n>>> foo()\n10\n11\n", "In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a value anywhere within the function\u2019s body, it\u2019s assumed to be a local unless explicitly declared as global.\nThough a bit surprising at first, a moment\u2019s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you\u2019d be using global all the time. You\u2019d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.\n", "Assume you use a for loop to define a few different lambdas (or even plain functions), e.g.:\n>>>\n>>> squares = []\n>>> for x in range(5):\n...     squares.append(lambda: x**2)\nThis gives you a list that contains 5 lambdas that calculate x**2. You might expect that, when called, they would return, respectively, 0, 1, 4, 9, and 16. However, when you actually try you will see that they all return 16:\n>>>\n>>> squares[2]()\n16\n>>> squares[4]()\n16\nThis happens because x is not local to the lambdas, but is defined in the outer scope, and it is accessed when the lambda is called \u2014 not when it is defined. At the end of the loop, the value of x is 4, so all the functions now return 4**2, i.e. 16. You can also verify this by changing the value of x and see how the results of the lambdas change:\n>>>\n>>> x = 8\n>>> squares[2]()\n64\nIn order to avoid this, you need to save the values in variables local to the lambdas, so that they don\u2019t rely on the value of the global x:\n>>>\n>>> squares = []\n>>> for x in range(5):\n...     squares.append(lambda n=x: n**2)\nHere, n=x creates a new variable n local to the lambda and computed when the lambda is defined so that it has the same value that x had at that point in the loop. This means that the value of n will be 0 in the first lambda, 1 in the second, 2 in the third, and so on. Therefore each lambda will now return the correct result:\n>>>\n>>> squares[2]()\n4\n>>> squares[4]()\n16\nNote that this behaviour is not peculiar to lambdas, but applies to regular functions too.\n", "The canonical way to share information across modules within a single program is to create a special module (often called config or cfg). Just import the config module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:\nconfig.py:\nx = 0   # Default value of the 'x' configuration setting\nmod.py:\nimport config\nconfig.x = 1\nmain.py:\nimport config\nimport mod\nprint(config.x)\nNote that using a module is also the basis for implementing the Singleton design pattern, for the same reason.\n", "In general, don\u2019t use from modulename import *. Doing so clutters the importer\u2019s namespace, and makes it much harder for linters to detect undefined names.\nImport modules at the top of a file. Doing so makes it clear what other modules your code requires and avoids questions of whether the module name is in scope. Using one import per line makes it easy to add and delete module imports, but using multiple imports per line uses less screen space.\nIt\u2019s good practice if you import modules in the following order:\nstandard library modules \u2013 e.g. sys, os, getopt, re\nthird-party library modules (anything installed in Python\u2019s site-packages directory) \u2013 e.g. mx.DateTime, ZODB, PIL.Image, etc.\nlocally-developed modules\nIt is sometimes necessary to move imports to a function or class to avoid problems with circular imports. Gordon McMillan says:\nCircular imports are fine where both modules use the \u201cimport <module>\u201d form of import. They fail when the 2nd module wants to grab a name out of the first (\u201cfrom module import name\u201d) and the import is at the top level. That\u2019s because names in the 1st are not yet available, because the first module is busy importing the 2nd.\nIn this case, if the second module is only used in one function, then the import can easily be moved into that function. By the time the import is called, the first module will have finished initializing, and the second module can do its import.\nIt may also be necessary to move imports out of the top level of code if some of the modules are platform-specific. In that case, it may not even be possible to import all of the modules at the top of the file. In this case, importing the correct modules in the corresponding platform-specific code is a good option.\nOnly move imports into a local scope, such as inside a function definition, if it\u2019s necessary to solve a problem such as avoiding a circular import or are trying to reduce the initialization time of a module. This technique is especially helpful if many of the imports are unnecessary depending on how the program executes. You may also want to move imports into a function if the modules are only ever used in that function. Note that loading a module the first time may be expensive because of the one time initialization of the module, but loading a module multiple times is virtually free, costing only a couple of dictionary lookups. Even if the module name has gone out of scope, the module is probably available in sys.modules.\n", "This type of bug commonly bites neophyte programmers. Consider this function:\ndef foo(mydict={}):  # Danger: shared reference to one dict for all calls\n    ... compute something ...\n    mydict[key] = value\n    return mydict\nThe first time you call this function, mydict contains a single item. The second time, mydict contains two items because when foo() begins executing, mydict starts out with an item already in it.\nIt is often expected that a function call creates new objects for default values. This is not what happens. Default values are created exactly once, when the function is defined. If that object is changed, like the dictionary in this example, subsequent calls to the function will refer to this changed object.\nBy definition, immutable objects such as numbers, strings, tuples, and None, are safe from change. Changes to mutable objects such as dictionaries, lists, and class instances can lead to confusion.\nBecause of this feature, it is good programming practice to not use mutable objects as default values. Instead, use None as the default value and inside the function, check if the parameter is None and create a new list/dictionary/whatever if it is. For example, don\u2019t write:\ndef foo(mydict={}):\n    ...\nbut:\ndef foo(mydict=None):\n    if mydict is None:\n        mydict = {}  # create a new dict for local namespace\nThis feature can be useful. When you have a function that\u2019s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called \u201cmemoizing\u201d, and can be implemented like this:\n# Callers can only provide two parameters and optionally pass _cache by keyword\ndef expensive(arg1, arg2, *, _cache={}):\n    if (arg1, arg2) in _cache:\n        return _cache[(arg1, arg2)]\n    # Calculate the value\n    result = ... expensive computation ...\n    _cache[(arg1, arg2)] = result           # Store result in the cache\n    return result\nYou could use a global variable containing a dictionary instead of the default value; it\u2019s a matter of taste.\n", "Collect the arguments using the * and ** specifiers in the function\u2019s parameter list; this gives you the positional arguments as a tuple and the keyword arguments as a dictionary. You can then pass these arguments when calling another function by using * and **:\ndef f(x, *args, **kwargs):\n    ...\n    kwargs['width'] = '14.3c'\n    ...\n    g(x, *args, **kwargs)\n", "Parameters are defined by the names that appear in a function definition, whereas arguments are the values actually passed to a function when calling it. Parameters define what types of arguments a function can accept. For example, given the function definition:\ndef func(foo, bar=None, **kwargs):\n    pass\nfoo, bar and kwargs are parameters of func. However, when calling func, for example:\nfunc(42, bar=314, extra=somevar)\nthe values 42, 314, and somevar are arguments.\n", "If you wrote code like:\n>>>\n>>> x = []\n>>> y = x\n>>> y.append(10)\n>>> y\n[10]\n>>> x\n[10]\nyou might be wondering why appending an element to y changed x too.\nThere are two factors that produce this result:\nVariables are simply names that refer to objects. Doing y = x doesn\u2019t create a copy of the list \u2013 it creates a new variable y that refers to the same object x refers to. This means that there is only one object (the list), and both x and y refer to it.\nLists are mutable, which means that you can change their content.\nAfter the call to append(), the content of the mutable object has changed from [] to [10]. Since both the variables refer to the same object, using either name accesses the modified value [10].\nIf we instead assign an immutable object to x:\n>>>\n>>> x = 5  # ints are immutable\n>>> y = x\n>>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n>>> x\n6\n>>> y\n5\nwe can see that in this case x and y are not equal anymore. This is because integers are immutable, and when we do x = x + 1 we are not mutating the int 5 by incrementing its value; instead, we are creating a new object (the int 6) and assigning it to x (that is, changing which object x refers to). After this assignment we have two objects (the ints 6 and 5) and two variables that refer to them (x now refers to 6 but y still refers to 5).\nSome operations (for example y.append(10) and y.sort()) mutate the object, whereas superficially similar operations (for example y = y + [10] and sorted(y)) create a new object. In general in Python (and in all cases in the standard library) a method that mutates an object will return None to help avoid getting the two types of operations confused. So if you mistakenly write y.sort() thinking it will give you a sorted copy of y, you\u2019ll instead end up with None, which will likely cause your program to generate an easily diagnosed error.\nHowever, there is one class of operations where the same operation sometimes has different behaviors with different types: the augmented assignment operators. For example, += mutates lists but not tuples or ints (a_list += [1, 2, 3] is equivalent to a_list.extend([1, 2, 3]) and mutates a_list, whereas some_tuple += (1, 2, 3) and some_int += 1 create new objects).\nIn other words:\nIf we have a mutable object (list, dict, set, etc.), we can use some specific operations to mutate it and all the variables that refer to it will see the change.\nIf we have an immutable object (str, int, tuple, etc.), all the variables that refer to it will always see the same value, but operations that transform that value into a new value always return a new object.\nIf you want to know if two variables refer to the same object or not, you can use the is operator, or the built-in function id().\n", "Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se. You can achieve the desired effect in a number of ways.\nBy returning a tuple of the results:\ndef func2(a, b):\n    a = 'new-value'        # a and b are local names\n    b = b + 1              # assigned to new objects\n    return a, b            # return new values\nx, y = 'old-value', 99\nx, y = func2(x, y)\nprint(x, y)                # output: new-value 100\nThis is almost always the clearest solution.\nBy using global variables. This isn\u2019t thread-safe, and is not recommended.\nBy passing a mutable (changeable in-place) object:\ndef func1(a):\n    a[0] = 'new-value'     # 'a' references a mutable list\n    a[1] = a[1] + 1        # changes a shared object\nargs = ['old-value', 99]\nfunc1(args)\nprint(args[0], args[1])    # output: new-value 100\nBy passing in a dictionary that gets mutated:\ndef func3(args):\n    args['a'] = 'new-value'     # args is a mutable dictionary\n    args['b'] = args['b'] + 1   # change it in-place\nargs = {'a': 'old-value', 'b': 99}\nfunc3(args)\nprint(args['a'], args['b'])\nOr bundle up values in a class instance:\nclass callByRef:\n    def __init__(self, **args):\n        for (key, value) in args.items():\n            setattr(self, key, value)\ndef func4(args):\n    args.a = 'new-value'        # args is a mutable callByRef\n    args.b = args.b + 1         # change object in-place\nargs = callByRef(a='old-value', b=99)\nfunc4(args)\nprint(args.a, args.b)\nThere\u2019s almost never a good reason to get this complicated.\nYour best choice is to return a tuple containing the multiple results.\n", "You have two choices: you can use nested scopes or you can use callable objects. For example, suppose you wanted to define linear(a,b) which returns a function f(x) that computes the value a*x+b. Using nested scopes:\ndef linear(a, b):\n    def result(x):\n        return a * x + b\n    return result\nOr using a callable object:\nclass linear:\n    def __init__(self, a, b):\n        self.a, self.b = a, b\n    def __call__(self, x):\n        return self.a * x + self.b\nIn both cases,\ntaxes = linear(0.3, 2)\ngives a callable object where taxes(10e6) == 0.3 * 10e6 + 2.\nThe callable object approach has the disadvantage that it is a bit slower and results in slightly longer code. However, note that a collection of callables can share their signature via inheritance:\nclass exponential(linear):\n    # __init__ inherited\n    def __call__(self, x):\n        return self.a * (x ** self.b)\nObject can encapsulate state for several methods:\nclass counter:\n    value = 0\n    def set(self, x):\n        self.value = x\n    def up(self):\n        self.value = self.value + 1\n    def down(self):\n        self.value = self.value - 1\ncount = counter()\ninc, dec, reset = count.up, count.down, count.set\nHere inc(), dec() and reset() act like functions which share the same counting variable.\n", "In general, try copy.copy() or copy.deepcopy() for the general case. Not all objects can be copied, but most can.\nSome objects can be copied more easily. Dictionaries have a copy() method:\nnewdict = olddict.copy()\nSequences can be copied by slicing:\nnew_l = l[:]\n", "For an instance x of a user-defined class, dir(x) returns an alphabetized list of the names containing the instance attributes and methods and attributes defined by its class.\n", "Generally speaking, it can\u2019t, because objects don\u2019t really have names. Essentially, assignment always binds a name to a value; The same is true of def and class statements, but in that case the value is a callable. Consider the following code:\n>>>\n>>> class A:\n...     pass\n...\n>>> B = A\n>>> a = B()\n>>> b = a\n>>> print(b)\n<__main__.A object at 0x16D07CC>\n>>> print(a)\n<__main__.A object at 0x16D07CC>\nArguably the class has a name: even though it is bound to two names and invoked through the name B the created instance is still reported as an instance of class A. However, it is impossible to say whether the instance\u2019s name is a or b, since both names are bound to the same value.\nGenerally speaking it should not be necessary for your code to \u201cknow the names\u201d of particular values. Unless you are deliberately writing introspective programs, this is usually an indication that a change of approach might be beneficial.\nIn comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to this question:\nThe same way as you get the name of that cat you found on your porch: the cat (object) itself cannot tell you its name, and it doesn\u2019t really care \u2013 so the only way to find out what it\u2019s called is to ask all your neighbours (namespaces) if it\u2019s their cat (object)\u2026\n\u2026.and don\u2019t be surprised if you\u2019ll find that it\u2019s known by many names, or no name at all!\n", "Comma is not an operator in Python. Consider this session:\n>>>\n>>> \"a\" in \"b\", \"a\"\n(False, 'a')\nSince the comma is not an operator, but a separator between expressions the above is evaluated as if you had entered:\n(\"a\" in \"b\"), \"a\"\nnot:\n\"a\" in (\"b\", \"a\")\nThe same is true of the various assignment operators (=, += etc). They are not truly operators but syntactic delimiters in assignment statements.\n", "Yes, there is. The syntax is as follows:\n[on_true] if [expression] else [on_false]\nx, y = 50, 25\nsmall = x if x < y else y\nBefore this syntax was introduced in Python 2.5, a common idiom was to use logical operators:\n[expression] and [on_true] or [on_false]\nHowever, this idiom is unsafe, as it can give wrong results when on_true has a false boolean value. Therefore, it is always better to use the ... if ... else ... form.\n", "Yes. Usually this is done by nesting lambda within lambda. See the following three examples, due to Ulf Bartelt:\nfrom functools import reduce\n# Primes < 1000\nprint(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\nmap(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n# First 10 Fibonacci numbers\nprint(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\nf(x,f), range(10))))\n# Mandelbrot set\nprint((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,\nIu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\nSx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\ni=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n>=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n#        V          V      |   |______ columns on screen\n#        |          |      |__________ maximum of \"iterations\"\n#        |          |_________________ range on y axis\n#        |____________________________ range on x axis\nDon\u2019t try this at home, kids!\n", "A slash in the argument list of a function denotes that the parameters prior to it are positional-only. Positional-only parameters are the ones without an externally-usable name. Upon calling a function that accepts positional-only parameters, arguments are mapped to parameters based solely on their position. For example, pow() is a function that accepts positional-only parameters. Its documentation looks like this:\n>>>\n>>> help(pow)\nHelp on built-in function pow in module builtins:\npow(x, y, z=None, /)\n   Equivalent to x**y (with two arguments) or x**y % z (with three arguments)\n   Some types, such as ints, are able to use a more efficient algorithm when\n   invoked using the three argument form.\nThe slash at the end of the parameter list means that all three parameters are positional-only. Thus, calling pow() with keyword aguments would lead to an error:\n>>>\n>>> pow(x=3, y=4)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: pow() takes no keyword arguments\nNote that as of this writing this is only documentational and no valid syntax in Python, although there is PEP 570, which proposes a syntax for position-only parameters in Python.\n", "To specify an octal digit, precede the octal value with a zero, and then a lower or uppercase \u201co\u201d. For example, to set the variable \u201ca\u201d to the octal value \u201c10\u201d (8 in decimal), type:\n>>>\n>>> a = 0o10\n>>> a\n8\nHexadecimal is just as easy. Simply precede the hexadecimal number with a zero, and then a lower or uppercase \u201cx\u201d. Hexadecimal digits can be specified in lower or uppercase. For example, in the Python interpreter:\n>>>\n>>> a = 0xa5\n>>> a\n165\n>>> b = 0XB2\n>>> b\n178\n", "It\u2019s primarily driven by the desire that i % j have the same sign as j. If you want that, and also want:\ni == (i // j) * j + (i % j)\nthen integer division has to return the floor. C also requires that identity to hold, and then compilers that truncate i // j need to make i % j have the same sign as i.\nThere are few real use cases for i % j when j is negative. When j is positive, there are many, and in virtually all of them it\u2019s more useful for i % j to be >= 0. If the clock says 10 now, what did it say 200 hours ago? -190 % 12 == 2 is useful; -190 % 12 == -10 is a bug waiting to bite.\n", "For integers, use the built-in int() type constructor, e.g. int('144') == 144. Similarly, float() converts to floating-point, e.g. float('144') == 144.0.\nBy default, these interpret the number as decimal, so that int('0144') == 144 and int('0x144') raises ValueError. int(string, base) takes the base to convert from as a second optional argument, so int('0x144', 16) == 324. If the base is specified as 0, the number is interpreted using Python\u2019s rules: a leading \u20180o\u2019 indicates octal, and \u20180x\u2019 indicates a hex number.\nDo not use the built-in function eval() if all you need is to convert strings to numbers. eval() will be significantly slower and it presents a security risk: someone could pass you a Python expression that might have unwanted side effects. For example, someone could pass __import__('os').system(\"rm -rf $HOME\") which would erase your home directory.\neval() also has the effect of interpreting numbers as Python expressions, so that e.g. eval('09') gives a syntax error because Python does not allow leading \u20180\u2019 in a decimal number (except \u20180\u2019).\n", "To convert, e.g., the number 144 to the string \u2018144\u2019, use the built-in type constructor str(). If you want a hexadecimal or octal representation, use the built-in functions hex() or oct(). For fancy formatting, see the Formatted string literals and Format String Syntax sections, e.g. \"{:04d}\".format(144) yields '0144' and \"{:.3f}\".format(1.0/3.0) yields '0.333'.\n", "You can\u2019t, because strings are immutable. In most situations, you should simply construct a new string from the various parts you want to assemble it from. However, if you need an object with the ability to modify in-place unicode data, try using an io.StringIO object or the array module:\n>>>\n>>> import io\n>>> s = \"Hello, world\"\n>>> sio = io.StringIO(s)\n>>> sio.getvalue()\n'Hello, world'\n>>> sio.seek(7)\n7\n>>> sio.write(\"there!\")\n6\n>>> sio.getvalue()\n'Hello, there!'\n>>> import array\n>>> a = array.array('u', s)\n>>> print(a)\narray('u', 'Hello, world')\n>>> a[0] = 'y'\n>>> print(a)\narray('u', 'yello, world')\n>>> a.tounicode()\n'yello, world'\n", "There are various techniques.\nThe best is to use a dictionary that maps strings to functions. The primary advantage of this technique is that the strings do not need to match the names of the functions. This is also the primary technique used to emulate a case construct:\ndef a():\n    pass\ndef b():\n    pass\ndispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\ndispatch[get_input()]()  # Note trailing parens to call function\nUse the built-in function getattr():\nimport foo\ngetattr(foo, 'bar')()\nNote that getattr() works on any object, including classes, class instances, modules, and so on.\nThis is used in several places in the standard library, like this:\nclass Foo:\n    def do_foo(self):\n        ...\n    def do_bar(self):\n        ...\nf = getattr(foo_instance, 'do_' + opname)\nf()\nUse locals() or eval() to resolve the function name:\ndef myFunc():\n    print(\"hello\")\nfname = \"myFunc\"\nf = locals()[fname]\nf()\nf = eval(fname)\nf()\nNote: Using eval() is slow and dangerous. If you don\u2019t have absolute control over the contents of the string, someone could pass a string that resulted in an arbitrary function being executed.\n", "You can use S.rstrip(\"\r\n\") to remove all occurrences of any line terminator from the end of the string S without removing other trailing whitespace. If the string S represents more than one line, with several empty lines at the end, the line terminators for all the blank lines will be removed:\n>>>\n>>> lines = (\"line 1 \r\n\"\n...          \"\r\n\"\n...          \"\r\n\")\n>>> lines.rstrip(\"\n\r\")\n'line 1 '\nSince this is typically only desired when reading text one line at a time, using S.rstrip() this way works well.\n", "Not as such.\nFor simple input parsing, the easiest approach is usually to split the line into whitespace-delimited words using the split() method of string objects and then convert decimal strings to numeric values using int() or float(). split() supports an optional \u201csep\u201d parameter which is useful if the line uses something other than whitespace as a separator.\nFor more complicated input parsing, regular expressions are more powerful than C\u2019s sscanf() and better suited for the task.\n", "str and bytes objects are immutable, therefore concatenating many strings together is inefficient as each concatenation creates a new object. In the general case, the total runtime cost is quadratic in the total string length.\nTo accumulate many str objects, the recommended idiom is to place them into a list and call str.join() at the end:\nchunks = []\nfor s in my_strings:\n    chunks.append(s)\nresult = ''.join(chunks)\n(another reasonably efficient idiom is to use io.StringIO)\nTo accumulate many bytes objects, the recommended idiom is to extend a bytearray object using in-place concatenation (the += operator):\nresult = bytearray()\nfor b in my_bytes_objects:\n    result += b\nSequences (Tuples/Lists)\n", "The type constructor tuple(seq) converts any sequence (actually, any iterable) into a tuple with the same items in the same order.\nFor example, tuple([1, 2, 3]) yields (1, 2, 3) and tuple('abc') yields ('a', 'b', 'c'). If the argument is a tuple, it does not make a copy but returns the same object, so it is cheap to call tuple() when you aren\u2019t sure that an object is already a tuple.\nThe type constructor list(seq) converts any sequence or iterable into a list with the same items in the same order. For example, list((1, 2, 3)) yields [1, 2, 3] and list('abc') yields ['a', 'b', 'c']. If the argument is a list, it makes a copy just like seq[:] would.\n", "Python sequences are indexed with positive numbers and negative numbers. For positive numbers 0 is the first index 1 is the second index and so forth. For negative indices -1 is the last index and -2 is the penultimate (next to last) index and so forth. Think of seq[-n] as the same as seq[len(seq)-n].\nUsing negative indices can be very convenient. For example S[:-1] is all of the string except for its last character, which is useful for removing the trailing newline from a string.\n", "Use the reversed() built-in function, which is new in Python 2.4:\nfor x in reversed(sequence):\n    ...  # do something with x ...\nThis won\u2019t touch your original sequence, but build a new copy with reversed order to iterate over.\nWith Python 2.3, you can use an extended slice syntax:\nfor x in sequence[::-1]:\n    ...  # do something with x ...\n", "See the Python Cookbook for a long discussion of many ways to do this:\nhttps://code.activestate.com/recipes/52560/\nIf you don\u2019t mind reordering the list, sort it and then scan from the end of the list, deleting duplicates as you go:\nif mylist:\n    mylist.sort()\n    last = mylist[-1]\n    for i in range(len(mylist)-2, -1, -1):\n        if last == mylist[i]:\n            del mylist[i]\n        else:\n            last = mylist[i]\nIf all elements of the list may be used as set keys (i.e. they are all hashable) this is often faster\nmylist = list(set(mylist))\nThis converts the list into a set, thereby removing duplicates, and then back into a list.\n", "Use a list:\n[\"this\", 1, \"is\", \"an\", \"array\"]\nLists are equivalent to C or Pascal arrays in their time complexity; the primary difference is that a Python list can contain objects of many different types.\nThe array module also provides methods for creating arrays of fixed types with compact representations, but they are slower to index than lists. Also note that the Numeric extensions and others define array-like structures with various characteristics as well.\nTo get Lisp-style linked lists, you can emulate cons cells using tuples:\nlisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )\nIf mutability is desired, you could use lists instead of tuples. Here the analogue of lisp car is lisp_list[0] and the analogue of cdr is lisp_list[1]. Only do this if you\u2019re sure you really need to, because it\u2019s usually a lot slower than using Python lists.\n", "You probably tried to make a multidimensional array like this:\n>>>\n>>> A = [[None] * 2] * 3\nThis looks correct if you print it:\n>>> A\n[[None, None], [None, None], [None, None]]\nBut when you assign a value, it shows up in multiple places:\n>>> A[0][0] = 5\n>>> A\n[[5, None], [5, None], [5, None]]\nThe reason is that replicating a list with * doesn\u2019t create copies, it only creates references to the existing objects. The *3 creates a list containing 3 references to the same list of length two. Changes to one row will show in all rows, which is almost certainly not what you want.\nThe suggested approach is to create a list of the desired length first and then fill in each element with a newly created list:\nA = [None] * 3\nfor i in range(3):\n    A[i] = [None] * 2\nThis generates a list containing 3 different lists of length two. You can also use a list comprehension:\nw, h = 2, 3\nA = [[None] * w for i in range(h)]\nOr, you can use an extension that provides a matrix datatype; NumPy is the best known.\n", "Use a list comprehension:\nresult = [obj.method() for obj in mylist]\n", "This is because of a combination of the fact that augmented assignment operators are assignment operators, and the difference between mutable and immutable objects in Python.\nThis discussion applies in general when augmented assignment operators are applied to elements of a tuple that point to mutable objects, but we\u2019ll use a list and += as our exemplar.\nIf you wrote:\n>>>\n>>> a_tuple = (1, 2)\n>>> a_tuple[0] += 1\nTraceback (most recent call last):\n   ...\nTypeError: 'tuple' object does not support item assignment\nThe reason for the exception should be immediately clear: 1 is added to the object a_tuple[0] points to (1), producing the result object, 2, but when we attempt to assign the result of the computation, 2, to element 0 of the tuple, we get an error because we can\u2019t change what an element of a tuple points to.\nUnder the covers, what this augmented assignment statement is doing is approximately this:\n>>>\n>>> result = a_tuple[0] + 1\n>>> a_tuple[0] = result\nTraceback (most recent call last):\n  ...\nTypeError: 'tuple' object does not support item assignment\nIt is the assignment part of the operation that produces the error, since a tuple is immutable.\nWhen you write something like:\n>>>\n>>> a_tuple = (['foo'], 'bar')\n>>> a_tuple[0] += ['item']\nTraceback (most recent call last):\n  ...\nTypeError: 'tuple' object does not support item assignment\nThe exception is a bit more surprising, and even more surprising is the fact that even though there was an error, the append worked:\n>>>\n>>> a_tuple[0]\n['foo', 'item']\nTo see why this happens, you need to know that (a) if an object implements an __iadd__ magic method, it gets called when the += augmented assignment is executed, and its return value is what gets used in the assignment statement; and (b) for lists, __iadd__ is equivalent to calling extend on the list and returning the list. That\u2019s why we say that for lists, += is a \u201cshorthand\u201d for list.extend:\n>>>\n>>> a_list = []\n>>> a_list += [1]\n>>> a_list\n[1]\nThis is equivalent to:\n>>>\n>>> result = a_list.__iadd__([1])\n>>> a_list = result\nThe object pointed to by a_list has been mutated, and the pointer to the mutated object is assigned back to a_list. The end result of the assignment is a no-op, since it is a pointer to the same object that a_list was previously pointing to, but the assignment still happens.\nThus, in our tuple example what is happening is equivalent to:\n>>>\n>>> result = a_tuple[0].__iadd__(['item'])\n>>> a_tuple[0] = result\nTraceback (most recent call last):\n  ...\nTypeError: 'tuple' object does not support item assignment\nThe __iadd__ succeeds, and thus the list is extended, but even though result points to the same object that a_tuple[0] already points to, that final assignment still results in an error, because tuples are immutable.\n", "The technique, attributed to Randal Schwartz of the Perl community, sorts the elements of a list by a metric which maps each element to its \u201csort value\u201d. In Python, use the key argument for the list.sort() method:\nIsorted = L[:]\nIsorted.sort(key=lambda s: int(s[10:15]))\n", "Merge them into an iterator of tuples, sort the resulting list, and then pick out the element you want.\n>>>\n>>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n>>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n>>> pairs = zip(list1, list2)\n>>> pairs = sorted(pairs)\n>>> pairs\n[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\n>>> result = [x[1] for x in pairs]\n>>> result\n['else', 'sort', 'to', 'something']\nAn alternative for the last step is:\n>>>\n>>> result = []\n>>> for p in pairs: result.append(p[1])\nIf you find this more legible, you might prefer to use this instead of the final list comprehension. However, it is almost twice as slow for long lists. Why? First, the append() operation has to reallocate memory, and while it uses some tricks to avoid doing that each time, it still has to do it occasionally, and that costs quite a bit. Second, the expression \u201cresult.append\u201d requires an extra attribute lookup, and third, there\u2019s a speed reduction from having to make all those function calls.\n", "A class is the particular object type created by executing a class statement. Class objects are used as templates to create instance objects, which embody both the data (attributes) and code (methods) specific to a datatype.\nA class can be based on one or more other classes, called its base class(es). It then inherits the attributes and methods of its base classes. This allows an object model to be successively refined by inheritance. You might have a generic Mailbox class that provides basic accessor methods for a mailbox, and subclasses such as MboxMailbox, MaildirMailbox, OutlookMailbox that handle various specific mailbox formats.\n", "A method is a function on some object x that you normally call as x.name(arguments...). Methods are defined as functions inside the class definition:\nclass C:\n    def meth(self, arg):\n        return arg * 2 + self.attribute\n", "Self is merely a conventional name for the first argument of a method. A method defined as meth(self, a, b, c) should be called as x.meth(a, b, c) for some instance x of the class in which the definition occurs; the called method will think it is called as meth(x, a, b, c).\nSee also Why must \u2018self\u2019 be used explicitly in method definitions and calls?.\n", "Use the built-in function isinstance(obj, cls). You can check if an object is an instance of any of a number of classes by providing a tuple instead of a single class, e.g. isinstance(obj, (class1, class2, ...)), and can also check whether an object is one of Python\u2019s built-in types, e.g. isinstance(obj, str) or isinstance(obj, (int, float, complex)).\nNote that most programs do not use isinstance() on user-defined classes very often. If you are developing the classes yourself, a more proper object-oriented style is to define methods on the classes that encapsulate a particular behaviour, instead of checking the object\u2019s class and doing a different thing based on what class it is. For example, if you have a function that does something:\ndef search(obj):\n    if isinstance(obj, Mailbox):\n        ...  # code to search a mailbox\n    elif isinstance(obj, Document):\n        ...  # code to search a document\n    elif ...\nA better approach is to define a search() method on all the classes and just call it:\nclass Mailbox:\n    def search(self):\n        ...  # code to search a mailbox\nclass Document:\n    def search(self):\n        ...  # code to search a document\nobj.search()\n", "Delegation is an object oriented technique (also called a design pattern). Let\u2019s say you have an object x and want to change the behaviour of just one of its methods. You can create a new class that provides a new implementation of the method you\u2019re interested in changing and delegates all other methods to the corresponding method of x.\nPython programmers can easily implement delegation. For example, the following class implements a class that behaves like a file but converts all written data to uppercase:\nclass UpperOut:\n    def __init__(self, outfile):\n        self._outfile = outfile\n    def write(self, s):\n        self._outfile.write(s.upper())\n    def __getattr__(self, name):\n        return getattr(self._outfile, name)\nHere the UpperOut class redefines the write() method to convert the argument string to uppercase before calling the underlying self.__outfile.write() method. All other methods are delegated to the underlying self.__outfile object. The delegation is accomplished via the __getattr__ method; consult the language reference for more information about controlling attribute access.\nNote that for more general cases delegation can get trickier. When attributes must be set as well as retrieved, the class must define a __setattr__() method too, and it must do so carefully. The basic implementation of __setattr__() is roughly equivalent to the following:\nclass X:\n    ...\n    def __setattr__(self, name, value):\n        self.__dict__[name] = value\n    ...\nMost __setattr__() implementations must modify self.__dict__ to store local state for self without causing an infinite recursion.\n", "Use the built-in super() function:\nclass Derived(Base):\n    def meth(self):\n        super(Derived, self).meth()\nFor version prior to 3.0, you may be using classic classes: For a class definition such as class Derived(Base): ... you can call method meth() defined in Base (or one of Base\u2019s base classes) as Base.meth(self, arguments...). Here, Base.meth is an unbound method, so you need to provide the self argument.\n", "You could define an alias for the base class, assign the real base class to it before your class definition, and use the alias throughout your class. Then all you have to change is the value assigned to the alias. Incidentally, this trick is also handy if you want to decide dynamically (e.g. depending on availability of resources) which base class to use. Example:\nBaseAlias = <real base class>\nclass Derived(BaseAlias):\n    def meth(self):\n        BaseAlias.meth(self)\n        ...\n", "Both static data and static methods (in the sense of C++ or Java) are supported in Python.\nFor static data, simply define a class attribute. To assign a new value to the attribute, you have to explicitly use the class name in the assignment:\nclass C:\n    count = 0   # number of times C.__init__ called\n    def __init__(self):\n        C.count = C.count + 1\n    def getcount(self):\n        return C.count  # or return self.count\nc.count also refers to C.count for any c such that isinstance(c, C) holds, unless overridden by c itself or by some class on the base-class search path from c.__class__ back to C.\nCaution: within a method of C, an assignment like self.count = 42 creates a new and unrelated instance named \u201ccount\u201d in self\u2019s own dict. Rebinding of a class-static data name must always specify the class whether inside a method or not:\nC.count = 314\nStatic methods are possible:\nclass C:\n    @staticmethod\n    def static(arg1, arg2, arg3):\n        # No 'self' parameter!\n        ...\nHowever, a far more straightforward way to get the effect of a static method is via a simple module-level function:\ndef getcount():\n    return C.count\nIf your code is structured so as to define one class (or tightly related class hierarchy) per module, this supplies the desired encapsulation.\n", "This answer actually applies to all methods, but the question usually comes up first in the context of constructors.\nIn C++ you\u2019d write\nclass C {\n    C() { cout << \"No arguments\n\"; }\n    C(int i) { cout << \"Argument is \" << i << \"\n\"; }\n}\nIn Python you have to write a single constructor that catches all cases using default arguments. For example:\nclass C:\n    def __init__(self, i=None):\n        if i is None:\n            print(\"No arguments\")\n        else:\n            print(\"Argument is\", i)\nThis is not entirely equivalent, but close enough in practice.\nYou could also try a variable-length argument list, e.g.\ndef __init__(self, *args):\n    ...\nThe same approach works for all method definitions.\nI try to use __spam and I get an error about _SomeClassName__spam.\nVariable names with double leading underscores are \u201cmangled\u201d to provide a simple but effective way to define class private variables. Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with any leading underscores stripped.\nThis doesn\u2019t guarantee privacy: an outside user can still deliberately access the \u201c_classname__spam\u201d attribute, and private values are visible in the object\u2019s __dict__. Many Python programmers never bother to use private variable names at all.\nMy class defines __del__ but it is not called when I delete the object.\nThere are several possible reasons for this.\nThe del statement does not necessarily call __del__() \u2013 it simply decrements the object\u2019s reference count, and if this reaches zero __del__() is called.\nIf your data structures contain circular links (e.g. a tree where each child has a parent reference and each parent has a list of children) the reference counts will never go back to zero. Once in a while Python runs an algorithm to detect such cycles, but the garbage collector might run some time after the last reference to your data structure vanishes, so your __del__() method may be called at an inconvenient and random time. This is inconvenient if you\u2019re trying to reproduce a problem. Worse, the order in which object\u2019s __del__() methods are executed is arbitrary. You can run gc.collect() to force a collection, but there are pathological cases where objects will never be collected.\nDespite the cycle collector, it\u2019s still a good idea to define an explicit close() method on objects to be called whenever you\u2019re done with them. The close() method can then remove attributes that refer to subobjects. Don\u2019t call __del__() directly \u2013 __del__() should call close() and close() should make sure that it can be called more than once for the same object.\nAnother way to avoid cyclical references is to use the weakref module, which allows you to point to objects without incrementing their reference count. Tree data structures, for instance, should use weak references for their parent and sibling references (if they need them!).\nFinally, if your __del__() method raises an exception, a warning message is printed to sys.stderr.\n", "Python does not keep track of all instances of a class (or of a built-in type). You can program the class\u2019s constructor to keep track of all instances by keeping a list of weak references to each instance.\n", "The id() builtin returns an integer that is guaranteed to be unique during the lifetime of the object. Since in CPython, this is the object\u2019s memory address, it happens frequently that after an object is deleted from memory, the next freshly created object is allocated at the same position in memory. This is illustrated by this example:\n>>> id(1000) # doctest: +SKIP\n13901272\n>>> id(2000) # doctest: +SKIP\n13901272\nThe two ids belong to different integer objects that are created before, and deleted immediately after execution of the id() call. To be sure that objects whose id you want to examine are still alive, create another reference to the object:\n>>> a = 1000; b = 2000\n>>> id(a) # doctest: +SKIP\n13901272\n>>> id(b) # doctest: +SKIP\n13891296\n", "Guido van Rossum believes that using indentation for grouping is extremely elegant and contributes a lot to the clarity of the average Python program. Most people learn to love this feature after a while.\nSince there are no begin/end brackets there cannot be a disagreement between grouping perceived by the parser and the human reader. Occasionally C programmers will encounter a fragment of code like this:\nif (x <= y)\n        x++;\n        y--;\nz++;\nOnly the x++ statement is executed if the condition is true, but the indentation leads you to believe otherwise. Even experienced C programmers will sometimes stare at it a long time wondering why y is being decremented even for x > y.\nBecause there are no begin/end brackets, Python is much less prone to coding-style conflicts. In C there are many different ways to place the braces. If you\u2019re used to reading and writing code that uses one style, you will feel at least slightly uneasy when reading (or being required to write) another style.\nMany coding styles place begin/end brackets on a line by themselves. This makes programs considerably longer and wastes valuable screen space, making it harder to get a good overview of a program. Ideally, a function should fit on one screen (say, 20\u201330 lines). 20 lines of Python can do a lot more work than 20 lines of C. This is not solely due to the lack of begin/end brackets \u2013 the lack of declarations and the high-level data types are also responsible \u2013 but the indentation-based syntax certainly helps.\n", "See the next question.\n", "Users are often surprised by results like this:\n>>>\n>>> 1.2 - 1.0\n0.19999999999999996\nand think it is a bug in Python. It\u2019s not. This has little to do with Python, and much more to do with how the underlying platform handles floating-point numbers.\nThe float type in CPython uses a C double for storage. A float object\u2019s value is stored in binary floating-point with a fixed precision (typically 53 bits) and Python uses C operations, which in turn rely on the hardware implementation in the processor, to perform floating-point operations. This means that as far as floating-point operations are concerned, Python behaves like many popular languages including C and Java.\nMany numbers that can be written easily in decimal notation cannot be expressed exactly in binary floating-point. For example, after:\n>>>\n>>> x = 1.2\nthe value stored for x is a (very good) approximation to the decimal value 1.2, but is not exactly equal to it. On a typical machine, the actual stored value is:\n1.0011001100110011001100110011001100110011001100110011 (binary)\nwhich is exactly:\n1.1999999999999999555910790149937383830547332763671875 (decimal)\nThe typical precision of 53 bits provides Python floats with 15\u201316 decimal digits of accuracy.\nFor a fuller explanation, please see the floating point arithmetic chapter in the Python tutorial.\n", "There are several advantages.\nOne is performance: knowing that a string is immutable means we can allocate space for it at creation time, and the storage requirements are fixed and unchanging. This is also one of the reasons for the distinction between tuples and lists.\nAnother advantage is that strings in Python are considered as \u201celemental\u201d as numbers. No amount of activity will change the value 8 to anything else, and in Python, no amount of activity will change the string \u201ceight\u201d to anything else.\n", "The idea was borrowed from Modula-3. It turns out to be very useful, for a variety of reasons.\nFirst, it\u2019s more obvious that you are using a method or instance attribute instead of a local variable. Reading self.x or self.meth() makes it absolutely clear that an instance variable or method is used even if you don\u2019t know the class definition by heart. In C++, you can sort of tell by the lack of a local variable declaration (assuming globals are rare or easily recognizable) \u2013 but in Python, there are no local variable declarations, so you\u2019d have to look up the class definition to be sure. Some C++ and Java coding standards call for instance attributes to have an m_ prefix, so this explicitness is still useful in those languages, too.\nSecond, it means that no special syntax is necessary if you want to explicitly reference or call the method from a particular class. In C++, if you want to use a method from a base class which is overridden in a derived class, you have to use the :: operator \u2013 in Python you can write baseclass.methodname(self, <argument list>). This is particularly useful for __init__() methods, and in general in cases where a derived class method wants to extend the base class method of the same name and thus has to call the base class method somehow.\nFinally, for instance variables it solves a syntactic problem with assignment: since local variables in Python are (by definition!) those variables to which a value is assigned in a function body (and that aren\u2019t explicitly declared global), there has to be some way to tell the interpreter that an assignment was meant to assign to an instance variable instead of to a local variable, and it should preferably be syntactic (for efficiency reasons). C++ does this through declarations, but Python doesn\u2019t have declarations and it would be a pity having to introduce them just for this purpose. Using the explicit self.var solves this nicely. Similarly, for using instance variables, having to write self.var means that references to unqualified names inside a method don\u2019t have to search the instance\u2019s directories. To put it another way, local variables and instance variables live in two different namespaces, and you need to tell Python which namespace to use.\n", "Many people used to C or Perl complain that they want to use this C idiom:\nwhile (line = readline(f)) {\n    // do something with line\n}\nwhere in Python you\u2019re forced to write this:\nwhile True:\n    line = f.readline()\n    if not line:\n        break\n    ...  # do something with line\nThe reason for not allowing assignment in Python expressions is a common, hard-to-find bug in those other languages, caused by this construct:\nif (x = 0) {\n    // error handling\n}\nelse {\n    // code that only works for nonzero x\n}\nThe error is a simple typo: x = 0, which assigns 0 to the variable x, was written while the comparison x == 0 is certainly what was intended.\nMany alternatives have been proposed. Most are hacks that save some typing but use arbitrary or cryptic syntax or keywords, and fail the simple criterion for language change proposals: it should intuitively suggest the proper meaning to a human reader who has not yet been introduced to the construct.\nAn interesting phenomenon is that most experienced Python programmers recognize the while True idiom and don\u2019t seem to be missing the assignment in expression construct much; it\u2019s only newcomers who express a strong desire to add this to the language.\nThere\u2019s an alternative way of spelling this that seems attractive but is generally less robust than the \u201cwhile True\u201d solution:\nline = f.readline()\nwhile line:\n    ...  # do something with line...\n    line = f.readline()\nThe problem with this is that if you change your mind about exactly how you get the next line (e.g. you want to change it into sys.stdin.readline()) you have to remember to change two places in your program \u2013 the second occurrence is hidden at the bottom of the loop.\nThe best approach is to use iterators, making it possible to loop through objects using the for statement. For example, file objects support the iterator protocol, so you can write simply:\nfor line in f:\n    ...  # do something with line...\n", "As Guido said:\n(a) For some operations, prefix notation just reads better than postfix \u2013 prefix (and infix!) operations have a long tradition in mathematics which likes notations where the visuals help the mathematician thinking about a problem. Compare the easy with which we rewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of doing the same thing using a raw OO notation.\n(b) When I read code that says len(x) I know that it is asking for the length of something. This tells me two things: the result is an integer, and the argument is some kind of container. To the contrary, when I read x.len(), I have to already know that x is some kind of container implementing an interface or inheriting from a class that has a standard len(). Witness the confusion we occasionally have when a class that is not implementing a mapping has a get() or keys() method, or something that isn\u2019t a file has a write() method.\n\u2014https://mail.python.org/pipermail/python-3000/2006-November/004643.html\n", "Strings became much more like other standard types starting in Python 1.6, when methods were added which give the same functionality that has always been available using the functions of the string module. Most of these new methods have been widely accepted, but the one which appears to make some programmers feel uncomfortable is:\n\", \".join(['1', '2', '4', '8', '16'])\nwhich gives the result:\n\"1, 2, 4, 8, 16\"\nThere are two common arguments against this usage.\nThe first runs along the lines of: \u201cIt looks really ugly using a method of a string literal (string constant)\u201d, to which the answer is that it might, but a string literal is just a fixed value. If the methods are to be allowed on names bound to strings there is no logical reason to make them unavailable on literals.\nThe second objection is typically cast as: \u201cI am really telling a sequence to join its members together with a string constant\u201d. Sadly, you aren\u2019t. For some reason there seems to be much less difficulty with having split() as a string method, since in that case it is easy to see that\n\"1, 2, 4, 8, 16\".split(\", \")\nis an instruction to a string literal to return the substrings delimited by the given separator (or, by default, arbitrary runs of white space).\njoin() is a string method because in using it you are telling the separator string to iterate over a sequence of strings and insert itself between adjacent elements. This method can be used with any argument which obeys the rules for sequence objects, including any new classes you might define yourself. Similar methods exist for bytes and bytearray objects.\n", "A try/except block is extremely efficient if no exceptions are raised. Actually catching an exception is expensive. In versions of Python prior to 2.0 it was common to use this idiom:\ntry:\n    value = mydict[key]\nexcept KeyError:\n    mydict[key] = getvalue(key)\n    value = mydict[key]\nThis only made sense when you expected the dict to have the key almost all the time. If that wasn\u2019t the case, you coded it like this:\nif key in mydict:\n    value = mydict[key]\nelse:\n    value = mydict[key] = getvalue(key)\nFor this specific case, you could also use value = dict.setdefault(key, getvalue(key)), but only if the getvalue() call is cheap enough because it is evaluated in all cases.\n", "You can do this easily enough with a sequence of if... elif... elif... else. There have been some proposals for switch statement syntax, but there is no consensus (yet) on whether and how to do range tests. See PEP 275 for complete details and the current status.\nFor cases where you need to choose from a very large number of possibilities, you can create a dictionary mapping case values to functions to call. For example:\ndef function_1(...):\n    ...\nfunctions = {'a': function_1,\n             'b': function_2,\n             'c': self.method_1, ...}\nfunc = functions[value]\nfunc()\nFor calling methods on objects, you can simplify yet further by using the getattr() built-in to retrieve methods with a particular name:\ndef visit_a(self, ...):\n    ...\n...\ndef dispatch(self, value):\n    method_name = 'visit_' + str(value)\n    method = getattr(self, method_name)\n    method()\nIt\u2019s suggested that you use a prefix for the method names, such as visit_ in this example. Without such a prefix, if values are coming from an untrusted source, an attacker would be able to call any method on your object.\n", "Answer 1: Unfortunately, the interpreter pushes at least one C stack frame for each Python stack frame. Also, extensions can call back into Python at almost random moments. Therefore, a complete threads implementation requires thread support for C.\nAnswer 2: Fortunately, there is Stackless Python, which has a completely redesigned interpreter loop that avoids the C stack.\n", "Python lambda expressions cannot contain statements because Python\u2019s syntactic framework can\u2019t handle statements nested inside expressions. However, in Python, this is not a serious problem. Unlike lambda forms in other languages, where they add functionality, Python lambdas are only a shorthand notation if you\u2019re too lazy to define a function.\nFunctions are already first class objects in Python, and can be declared in a local scope. Therefore the only advantage of using a lambda instead of a locally-defined function is that you don\u2019t need to invent a name for the function \u2013 but that\u2019s just a local variable to which the function object (which is exactly the same type of object that a lambda expression yields) is assigned!\n", "Cython compiles a modified version of Python with optional annotations into C extensions. Nuitka is an up-and-coming compiler of Python into C++ code, aiming to support the full Python language. For compiling to Java you can consider VOC.\n", "The details of Python memory management depend on the implementation. The standard implementation of Python, CPython, uses reference counting to detect inaccessible objects, and another mechanism to collect reference cycles, periodically executing a cycle detection algorithm which looks for inaccessible cycles and deletes the objects involved. The gc module provides functions to perform a garbage collection, obtain debugging statistics, and tune the collector\u2019s parameters.\nOther implementations (such as Jython or PyPy), however, can rely on a different mechanism such as a full-blown garbage collector. This difference can cause some subtle porting problems if your Python code depends on the behavior of the reference counting implementation.\nIn some Python implementations, the following code (which is fine in CPython) will probably run out of file descriptors:\nfor file in very_long_list_of_files:\n    f = open(file)\n    c = f.read(1)\nIndeed, using CPython\u2019s reference counting and destructor scheme, each new assignment to f closes the previous file. With a traditional GC, however, those file objects will only get collected (and closed) at varying and possibly long intervals.\nIf you want to write code that will work with any Python implementation, you should explicitly close the file or use the with statement; this will work regardless of memory management scheme:\nfor file in very_long_list_of_files:\n    with open(file) as f:\n        c = f.read(1)\n", "For one thing, this is not a C standard feature and hence it\u2019s not portable. (Yes, we know about the Boehm GC library. It has bits of assembler code for most common platforms, not for all of them, and although it is mostly transparent, it isn\u2019t completely transparent; patches are required to get Python to work with it.)\nTraditional GC also becomes a problem when Python is embedded into other applications. While in a standalone Python it\u2019s fine to replace the standard malloc() and free() with versions provided by the GC library, an application embedding Python may want to have its own substitute for malloc() and free(), and may not want Python\u2019s. Right now, CPython works with anything that implements malloc() and free() properly.\n", "Objects referenced from the global namespaces of Python modules are not always deallocated when Python exits. This may happen if there are circular references. There are also certain bits of memory that are allocated by the C library that are impossible to free (e.g. a tool like Purify will complain about these). Python is, however, aggressive about cleaning up memory on exit and does try to destroy every single object.\nIf you want to force Python to delete certain things on deallocation use the atexit module to run a function that will force those deletions.\n", "Lists and tuples, while similar in many respects, are generally used in fundamentally different ways. Tuples can be thought of as being similar to Pascal records or C structs; they\u2019re small collections of related data which may be of different types which are operated on as a group. For example, a Cartesian coordinate is appropriately represented as a tuple of two or three numbers.\nLists, on the other hand, are more like arrays in other languages. They tend to hold a varying number of objects all of which have the same type and which are operated on one-by-one. For example, os.listdir('.') returns a list of strings representing the files in the current directory. Functions which operate on this output would generally not break if you added another file or two to the directory.\nTuples are immutable, meaning that once a tuple has been created, you can\u2019t replace any of its elements with a new value. Lists are mutable, meaning that you can always change a list\u2019s elements. Only immutable elements can be used as dictionary keys, and hence only tuples and not lists can be used as keys.\n", "CPython\u2019s lists are really variable-length arrays, not Lisp-style linked lists. The implementation uses a contiguous array of references to other objects, and keeps a pointer to this array and the array\u2019s length in a list head structure.\nThis makes indexing a list a[i] an operation whose cost is independent of the size of the list or the value of the index.\nWhen items are appended or inserted, the array of references is resized. Some cleverness is applied to improve the performance of appending items repeatedly; when the array must be grown, some extra space is allocated so the next few times don\u2019t require an actual resize.\n", "CPython\u2019s dictionaries are implemented as resizable hash tables. Compared to B-trees, this gives better performance for lookup (the most common operation by far) under most circumstances, and the implementation is simpler.\nDictionaries work by computing a hash code for each key stored in the dictionary using the hash() built-in function. The hash code varies widely depending on the key and a per-process seed; for example, \u201cPython\u201d could hash to -539294296 while \u201cpython\u201d, a string that differs by a single bit, could hash to 1142331976. The hash code is then used to calculate a location in an internal array where the value will be stored. Assuming that you\u2019re storing keys that all have different hash values, this means that dictionaries take constant time \u2013 O(1), in Big-O notation \u2013 to retrieve a key.\n", "The hash table implementation of dictionaries uses a hash value calculated from the key value to find the key. If the key were a mutable object, its value could change, and thus its hash could also change. But since whoever changes the key object can\u2019t tell that it was being used as a dictionary key, it can\u2019t move the entry around in the dictionary. Then, when you try to look up the same object in the dictionary it won\u2019t be found because its hash value is different. If you tried to look up the old value it wouldn\u2019t be found either, because the value of the object found in that hash bin would be different.\nIf you want a dictionary indexed with a list, simply convert the list to a tuple first; the function tuple(L) creates a tuple with the same entries as the list L. Tuples are immutable and can therefore be used as dictionary keys.\nSome unacceptable solutions that have been proposed:\nHash lists by their address (object ID). This doesn\u2019t work because if you construct a new list with the same value it won\u2019t be found; e.g.:\nmydict = {[1, 2]: '12'}\nprint(mydict[[1, 2]])\nwould raise a KeyError exception because the id of the [1, 2] used in the second line differs from that in the first line. In other words, dictionary keys should be compared using ==, not using is.\nMake a copy when using a list as a key. This doesn\u2019t work because the list, being a mutable object, could contain a reference to itself, and then the copying code would run into an infinite loop.\nAllow lists as keys but tell the user not to modify them. This would allow a class of hard-to-track bugs in programs when you forgot or modified a list by accident. It also invalidates an important invariant of dictionaries: every value in d.keys() is usable as a key of the dictionary.\nMark lists as read-only once they are used as a dictionary key. The problem is that it\u2019s not just the top-level object that could change its value; you could use a tuple containing a list as a key. Entering anything as a key into a dictionary would require marking all objects reachable from there as read-only \u2013 and again, self-referential objects could cause an infinite loop.\nThere is a trick to get around this if you need to, but use it at your own risk: You can wrap a mutable structure inside a class instance which has both a __eq__() and a __hash__() method. You must then make sure that the hash value for all such wrapper objects that reside in a dictionary (or other hash based structure), remain fixed while the object is in the dictionary (or other structure).\nclass ListWrapper:\n    def __init__(self, the_list):\n        self.the_list = the_list\n    def __eq__(self, other):\n        return self.the_list == other.the_list\n    def __hash__(self):\n        l = self.the_list\n        result = 98767 - len(l)*555\n        for i, el in enumerate(l):\n            try:\n                result = result + (hash(el) % 9999999) * 1001 + i\n            except Exception:\n                result = (result % 7777777) + i * 333\n        return result\nNote that the hash computation is complicated by the possibility that some members of the list may be unhashable and also by the possibility of arithmetic overflow.\nFurthermore it must always be the case that if o1 == o2 (ie o1.__eq__(o2) is True) then hash(o1) == hash(o2) (ie, o1.__hash__() == o2.__hash__()), regardless of whether the object is in a dictionary or not. If you fail to meet these restrictions dictionaries and other hash based structures will misbehave.\nIn the case of ListWrapper, whenever the wrapper object is in a dictionary the wrapped list must not change to avoid anomalies. Don\u2019t do this unless you are prepared to think hard about the requirements and the consequences of not meeting them correctly. Consider yourself warned.\n", "In situations where performance matters, making a copy of the list just to sort it would be wasteful. Therefore, list.sort() sorts the list in place. In order to remind you of that fact, it does not return the sorted list. This way, you won\u2019t be fooled into accidentally overwriting a list when you need a sorted copy but also need to keep the unsorted version around.\nIf you want to return a new list, use the built-in sorted() function instead. This function creates a new list from a provided iterable, sorts it and returns it. For example, here\u2019s how to iterate over the keys of a dictionary in sorted order:\nfor key in sorted(mydict):\n    ...  # do whatever with mydict[key]...\n", "An interface specification for a module as provided by languages such as C++ and Java describes the prototypes for the methods and functions of the module. Many feel that compile-time enforcement of interface specifications helps in the construction of large programs.\nPython 2.6 adds an abc module that lets you define Abstract Base Classes (ABCs). You can then use isinstance() and issubclass() to check whether an instance or a class implements a particular ABC. The collections.abc module defines a set of useful ABCs such as Iterable, Container, and MutableMapping.\nFor Python, many of the advantages of interface specifications can be obtained by an appropriate test discipline for components. There is also a tool, PyChecker, which can be used to find problems due to subclassing.\nA good test suite for a module can both provide a regression test and serve as a module interface specification and a set of examples. Many Python modules can be run as a script to provide a simple \u201cself test.\u201d Even modules which use complex external interfaces can often be tested in isolation using trivial \u201cstub\u201d emulations of the external interface. The doctest and unittest modules or third-party test frameworks can be used to construct exhaustive test suites that exercise every line of code in a module.\nAn appropriate testing discipline can help build large complex applications in Python as well as having interface specifications would. In fact, it can be better because an interface specification cannot test certain properties of a program. For example, the append() method is expected to add new elements to the end of some internal list; an interface specification cannot test that your append() implementation will actually do this correctly, but it\u2019s trivial to check this property in a test suite.\nWriting test suites is very helpful, and you might want to design your code with an eye to making it easily tested. One increasingly popular technique, test-directed development, calls for writing parts of the test suite first, before you write any of the actual code. Of course Python allows you to be sloppy and not write test cases at all.\n", "You can use exceptions to provide a \u201cstructured goto\u201d that even works across function calls. Many feel that exceptions can conveniently emulate all reasonable uses of the \u201cgo\u201d or \u201cgoto\u201d constructs of C, Fortran, and other languages. For example:\nclass label(Exception): pass  # declare a label\ntry:\n    ...\n    if condition: raise label()  # goto label\n    ...\nexcept label:  # where to goto\n    pass\n...\nThis doesn\u2019t allow you to jump into the middle of a loop, but that\u2019s usually considered an abuse of goto anyway. Use sparingly.\n", "More precisely, they can\u2019t end with an odd number of backslashes: the unpaired backslash at the end escapes the closing quote character, leaving an unterminated string.\nRaw strings were designed to ease creating input for processors (chiefly regular expression engines) that want to do their own backslash escape processing. Such processors consider an unmatched trailing backslash to be an error anyway, so raw strings disallow that. In return, they allow you to pass on the string quote character by escaping it with a backslash. These rules work well when r-strings are used for their intended purpose.\nIf you\u2019re trying to build Windows pathnames, note that all Windows system calls accept forward slashes too:\nf = open(\"/mydir/file.txt\")  # works fine!\nIf you\u2019re trying to build a pathname for a DOS command, try e.g. one of\ndir = r\"\this\\is\\my\\dos\\dir\" \"\\\"\ndir = r\"\this\\is\\my\\dos\\dir\\ \"[:-1]\ndir = \"\\this\\is\\my\\dos\\dir\\\"\n", "Python has a \u2018with\u2019 statement that wraps the execution of a block, calling code on the entrance and exit from the block. Some language have a construct that looks like this:\nwith obj:\n    a = 1               # equivalent to obj.a = 1\n    total = total + 1   # obj.total = obj.total + 1\nIn Python, such a construct would be ambiguous.\nOther languages, such as Object Pascal, Delphi, and C++, use static types, so it\u2019s possible to know, in an unambiguous way, what member is being assigned to. This is the main point of static typing \u2013 the compiler always knows the scope of every variable at compile time.\n", "For instance, take the following incomplete snippet:\ndef foo(a):\n    with a:\n        print(x)\nThe snippet assumes that \u201ca\u201d must have a member attribute called \u201cx\u201d. However, there is nothing in Python that tells the interpreter this. What should happen if \u201ca\u201d is, let us say, an integer? If there is a global variable named \u201cx\u201d, will it be used inside the with block? As you see, the dynamic nature of Python makes such choices much harder.\nThe primary benefit of \u201cwith\u201d and similar language features (reduction of code volume) can, however, easily be achieved in Python by assignment. Instead of:\nfunction(args).mydict[index][index].a = 21\nfunction(args).mydict[index][index].b = 42\nfunction(args).mydict[index][index].c = 63\nwrite this:\nref = function(args).mydict[index][index]\nref.a = 21\nref.b = 42\nref.c = 63\nThis also has the side-effect of increasing execution speed because name bindings are resolved at run-time in Python, and the second version only needs to perform the resolution once.\n", "The colon is required primarily to enhance readability (one of the results of the experimental ABC language). Consider this:\nif a == b\n    print(a)\nversus\nif a == b:\n    print(a)\nNotice how the second one is slightly easier to read. Notice further how a colon sets off the example in this FAQ answer; it\u2019s a standard usage in English.\nAnother minor reason is that the colon makes it easier for editors with syntax highlighting; they can look for colons to decide when indentation needs to be increased instead of having to do a more elaborate parsing of the program text.\n", "Python lets you add a trailing comma at the end of lists, tuples, and dictionaries:\n[1, 2, 3,]\n('a', 'b', 'c',)\nd = {\n    \"A\": [1, 5],\n    \"B\": [6, 7],  # last trailing comma is optional but good style\n}\nThere are several reasons to allow this.\nWhen you have a literal value for a list, tuple, or dictionary spread across multiple lines, it\u2019s easier to add more elements because you don\u2019t have to remember to add a comma to the previous line. The lines can also be reordered without creating a syntax error.\nAccidentally omitting the comma can lead to errors that are hard to diagnose. For example:\nx = [\n  \"fee\",\n  \"fie\"\n  \"foo\",\n  \"fum\"\n]\nThis list looks like it has four elements, but it actually contains three: \u201cfee\u201d, \u201cfiefoo\u201d and \u201cfum\u201d. Always adding the comma avoids this source of error.\nAllowing the trailing comma may also make programmatic code generation easier.\n"]